// #target: macos-aarch64
module test;
import std, test2;

struct UJsonReader
{
    String last_error_file;
    String last_error_func;
    int last_error_line;
}

faultdef INVALID_KIND;

fn void? UJsonReader.dict(&self, String file = $$FILE, String func = $$FUNC, int line = $$LINE)
{
    self.last_error_file = file;
    self.last_error_func = func;
    self.last_error_line = line;
    return INVALID_KIND?;
}

fn int main()
{
    UJsonReader r;
    int a = $$LINE;
    @test(r.dict());
    (void)r.dict();
    return r.last_error_line;
}
module test2;
macro void @test(#expr) @builtin
{
	(void)#expr;
}

/* #expect: test.ll

define i32 @main() #0 {
entry:
  %r = alloca %UJsonReader, align 8
  %a = alloca i32, align 4
  %taddr = alloca %"char[]", align 8
  %taddr1 = alloca %"char[]", align 8
  %taddr2 = alloca %"char[]", align 8
  %taddr3 = alloca %"char[]", align 8
  call void @llvm.memset.p0.i64(ptr align 8 %r, i8 0, i64 40, i1 false)
  store i32 24, ptr %a, align 4
  store %"char[]" { ptr @.str, i64 15 }, ptr %taddr, align 8
  %0 = load [2 x i64], ptr %taddr, align 8
  store %"char[]" { ptr @.str.1, i64 4 }, ptr %taddr1, align 8
  %1 = load [2 x i64], ptr %taddr1, align 8
  %2 = call i64 @test.UJsonReader.dict(ptr %r, [2 x i64] %0, [2 x i64] %1, i32 25)
  store %"char[]" { ptr @.str.2, i64 15 }, ptr %taddr2, align 8
  %3 = load [2 x i64], ptr %taddr2, align 8
  store %"char[]" { ptr @.str.3, i64 4 }, ptr %taddr3, align 8
  %4 = load [2 x i64], ptr %taddr3, align 8
  %5 = call i64 @test.UJsonReader.dict(ptr %r, [2 x i64] %3, [2 x i64] %4, i32 26)
  %ptradd = getelementptr inbounds i8, ptr %r, i64 32
  %6 = load i32, ptr %ptradd, align 8
  ret i32 %6
}
