// #target: macos-x64
module inherit;
import std::io;

protocol Base
{
	fn void tesT();
}

protocol TestProto2 : Base
{
}

protocol TestProto : Base
{
	fn void hello();
}

fn void Test.tesT(&self) @dynamic
{
}

fn void Test.hello(&self) @dynamic
{
}

struct Test (TestProto, TestProto2)
{
	void* abc;
}

fn void main()
{
	TestProto* z = malloc(Test);
	z.tesT();
	Base* w = z;
	w.tesT();
}

/* #expect: inherit.ll


@"$ct.inherit.Test" = linkonce global %.introspect { i8 10, i64 0, ptr null, i64 8, i64 0, i64 1, [0 x i64] zeroinitializer }, align 8
@std.core.mem.thread_allocator = external thread_local global ptr, align 8
@"$ct.anyfault" = linkonce global %.introspect { i8 6, i64 0, ptr null, i64 8, i64 0, i64 0, [0 x i64] zeroinitializer }, align 8
@.panic_msg = internal constant [37 x i8] c"Unexpected fault '%s' was unwrapped!\00", align 1
@.file = internal constant [7 x i8] c"mem.c3\00", align 1
@.func = internal constant [5 x i8] c"main\00", align 1
@"$sel.tesT" = linkonce_odr constant [5 x i8] c"tesT\00", align 1
@.panic_msg.1 = internal constant [42 x i8] c"No method 'tesT' could be found on target\00", align 1
@.file.2 = internal constant [11 x i8] c"inherit.c3\00", align 1
@std.core.builtin.panic = external global ptr, align 8
@"$ct.dyn.inherit.Test.tesT" = global { ptr, ptr, ptr } { ptr @inherit.Test.tesT, ptr @"$sel.tesT", ptr null }, align 8
@"$ct.dyn.inherit.Test.hello" = global { ptr, ptr, ptr } { ptr @inherit.Test.hello, ptr @"$sel.hello", ptr null }, align 8
@"$sel.hello" = linkonce_odr constant [6 x i8] c"hello\00", align 1
@llvm.global_ctors = appending global [1 x { i32, ptr, ptr }] [{ i32, ptr, ptr } { i32 1, ptr @.static_initialize.0, ptr null }]

define void @inherit.main() #0 {
entry:
  %z = alloca %"any*", align 8
  %using = alloca ptr, align 8
  %error_var = alloca i64, align 8
  %using1 = alloca ptr, align 8
  %allocator = alloca ptr, align 8
  %retparam = alloca ptr, align 8
  %varargslots = alloca [1 x %"any*"], align 16
  %indirectarg = alloca %"any*[]", align 8
  %.inlinecache = alloca ptr, align 8
  %.cachedtype = alloca ptr, align 8
  %w = alloca %"any*", align 8
  %.inlinecache2 = alloca ptr, align 8
  %.cachedtype3 = alloca ptr, align 8
  store ptr null, ptr %.cachedtype3, align 8
  store ptr null, ptr %.cachedtype, align 8
  %0 = load ptr, ptr @std.core.mem.thread_allocator, align 8
  store ptr %0, ptr %using, align 8
  %1 = load ptr, ptr %using, align 8
  store ptr %1, ptr %using1, align 8
  %2 = load ptr, ptr %using1, align 8
  store ptr %2, ptr %allocator, align 8
  %3 = load ptr, ptr %allocator, align 8
  %4 = getelementptr inbounds %Allocator, ptr %3, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = load ptr, ptr %allocator, align 8
  %7 = call i64 %5(ptr %retparam, ptr %6, i64 8, i64 0, i64 0, ptr null, i32 0)
  %not_err = icmp eq i64 %7, 0
  %8 = call i1 @llvm.expect.i1(i1 %not_err, i1 true)
  br i1 %8, label %after_check, label %assign_optional

assign_optional:                                  ; preds = %entry
  store i64 %7, ptr %error_var, align 8
  br label %panic_block

after_check:                                      ; preds = %entry
  %9 = load ptr, ptr %retparam, align 8
  br label %noerr_block

panic_block:                                      ; preds = %assign_optional
  %10 = insertvalue %"any*" undef, ptr %error_var, 0
  %11 = insertvalue %"any*" %10, i64 ptrtoint (ptr @"$ct.anyfault" to i64), 1
  %12 = getelementptr inbounds [1 x %"any*"], ptr %varargslots, i64 0, i64 0
  store %"any*" %11, ptr %12, align 16
  %13 = insertvalue %"any*[]" undef, ptr %varargslots, 0
  %"#temp#" = insertvalue %"any*[]" %13, i64 1, 1
  store %"any*[]" %"#temp#", ptr %indirectarg, align 8
  call void @std.core.builtin.panicf(ptr @.panic_msg, i64 36, ptr @.file, i64 6, ptr @.func, i64 4, i32 392, ptr byval(%"any*[]") align 8 %indirectarg)
  unreachable

noerr_block:                                      ; preds = %after_check
  %14 = insertvalue %"any*" undef, ptr %9, 0
  %15 = insertvalue %"any*" %14, i64 ptrtoint (ptr @"$ct.inherit.Test" to i64), 1
  store %"any*" %15, ptr %z, align 8
  %16 = getelementptr inbounds %"any*", ptr %z, i32 0, i32 1
  %17 = load i64, ptr %16, align 8
  %18 = getelementptr inbounds %"any*", ptr %z, i32 0, i32 0
  %19 = inttoptr i64 %17 to ptr
  %type = load ptr, ptr %.cachedtype, align 8
  %20 = icmp eq ptr %19, %type
  br i1 %20, label %cache_hit, label %cache_miss

cache_miss:                                       ; preds = %noerr_block
  %21 = getelementptr inbounds %.introspect, ptr %19, i32 0, i32 2
  %22 = load ptr, ptr %21, align 8
  %23 = call ptr @.dyn_search(ptr %22, ptr @"$sel.tesT")
  store ptr %23, ptr %.inlinecache, align 8
  store ptr %19, ptr %.cachedtype, align 8
  br label %24

cache_hit:                                        ; preds = %noerr_block
  %cache_hit_fn = load ptr, ptr %.inlinecache, align 8
  br label %24

24:                                               ; preds = %cache_hit, %cache_miss
  %fn_phi = phi ptr [ %cache_hit_fn, %cache_hit ], [ %23, %cache_miss ]
  %25 = icmp eq ptr %fn_phi, null
  br i1 %25, label %missing_function, label %match

missing_function:                                 ; preds = %24
  %26 = load ptr, ptr @std.core.builtin.panic, align 8
  call void %26(ptr @.panic_msg.1, i64 41, ptr @.file.2, i64 10, ptr @.func, i64 4, i32 34)
  unreachable

match:                                            ; preds = %24
  %27 = load ptr, ptr %18, align 8
  call void %fn_phi(ptr %27)
  %28 = load %"any*", ptr %z, align 8
  store %"any*" %28, ptr %w, align 8
  %29 = getelementptr inbounds %"any*", ptr %w, i32 0, i32 1
  %30 = load i64, ptr %29, align 8
  %31 = getelementptr inbounds %"any*", ptr %w, i32 0, i32 0
  %32 = inttoptr i64 %30 to ptr
  %type4 = load ptr, ptr %.cachedtype3, align 8
  %33 = icmp eq ptr %32, %type4
  br i1 %33, label %cache_hit6, label %cache_miss5

cache_miss5:                                      ; preds = %match
  %34 = getelementptr inbounds %.introspect, ptr %32, i32 0, i32 2
  %35 = load ptr, ptr %34, align 8
  %36 = call ptr @.dyn_search(ptr %35, ptr @"$sel.tesT")
  store ptr %36, ptr %.inlinecache2, align 8
  store ptr %32, ptr %.cachedtype3, align 8
  br label %37

cache_hit6:                                       ; preds = %match
  %cache_hit_fn7 = load ptr, ptr %.inlinecache2, align 8
  br label %37

37:                                               ; preds = %cache_hit6, %cache_miss5
  %fn_phi8 = phi ptr [ %cache_hit_fn7, %cache_hit6 ], [ %36, %cache_miss5 ]
  %38 = icmp eq ptr %fn_phi8, null
  br i1 %38, label %missing_function9, label %match10

missing_function9:                                ; preds = %37
  %39 = load ptr, ptr @std.core.builtin.panic, align 8
  call void %39(ptr @.panic_msg.1, i64 41, ptr @.file.2, i64 10, ptr @.func, i64 4, i32 36)
  unreachable

match10:                                          ; preds = %37
  %40 = load ptr, ptr %31, align 8
  call void %fn_phi8(ptr %40)
  ret void
}


define weak_odr ptr @.dyn_search(ptr %0, ptr %1) unnamed_addr {
entry:
  br label %check

check:                                            ; preds = %no_match, %entry
  %2 = phi ptr [ %0, %entry ], [ %9, %no_match ]
  %3 = icmp eq ptr %2, null
  br i1 %3, label %missing_function, label %compare

missing_function:                                 ; preds = %check
  ret ptr null

compare:                                          ; preds = %check
  %4 = getelementptr inbounds { ptr, ptr, ptr }, ptr %2, i32 0, i32 1
  %5 = load ptr, ptr %4, align 8
  %6 = icmp eq ptr %5, %1
  br i1 %6, label %match, label %no_match

match:                                            ; preds = %compare
  %7 = load ptr, ptr %2, align 8
  ret ptr %7

no_match:                                         ; preds = %compare
  %8 = getelementptr inbounds { ptr, ptr, ptr }, ptr %2, i32 0, i32 2
  %9 = load ptr, ptr %8, align 8
  br label %check
}

define internal void @.static_initialize.0() {
entry:
  br label %dtable_check

dtable_check:                                     ; preds = %dtable_next, %entry
  %dtable_ref = phi ptr [ getelementptr inbounds (%.introspect, ptr @"$ct.inherit.Test", i32 0, i32 2), %entry ], [ %next_dtable_ref, %dtable_next ]
  %dtable_ptr = load ptr, ptr %dtable_ref, align 8
  %0 = icmp eq ptr %dtable_ptr, null
  br i1 %0, label %dtable_found, label %dtable_next

dtable_next:                                      ; preds = %dtable_check
  %next_dtable_ref = getelementptr inbounds { ptr, ptr, ptr }, ptr %dtable_ptr, i32 0, i32 2
  br label %dtable_check

dtable_found:                                     ; preds = %dtable_check
  store ptr @"$ct.dyn.inherit.Test.tesT", ptr %dtable_ref, align 8
  br label %dtable_check1

dtable_check1:                                    ; preds = %dtable_next4, %dtable_found
  %dtable_ref2 = phi ptr [ getelementptr inbounds (%.introspect, ptr @"$ct.inherit.Test", i32 0, i32 2), %dtable_found ], [ %next_dtable_ref5, %dtable_next4 ]
  %dtable_ptr3 = load ptr, ptr %dtable_ref2, align 8
  %1 = icmp eq ptr %dtable_ptr3, null
  br i1 %1, label %dtable_found6, label %dtable_next4

dtable_next4:                                     ; preds = %dtable_check1
  %next_dtable_ref5 = getelementptr inbounds { ptr, ptr, ptr }, ptr %dtable_ptr3, i32 0, i32 2
  br label %dtable_check1

dtable_found6:                                    ; preds = %dtable_check1
  store ptr @"$ct.dyn.inherit.Test.hello", ptr %dtable_ref2, align 8
  ret void
}
