// #target: macos-x64
module test;
import std::io;

fault Foo { ABC, DEF }

fn void main()
{
	io::printfn("1:%d", get_a(1) ?? get_b(4) ?? -1);
	io::printfn("2:%d", get_a(2) ?? get_b(4) ?? -1);
	io::printfn("3:%d", get_a(1) ?? get_b(5) ?? -1);
	io::printfn("4:%s", catch? (Foo.ABC! ?? Foo.DEF!));
	io::printfn("5:%s", Foo.ABC! ?? 3);
	io::printfn("6:%s", catch? ((3 > 2 ? Foo.ABC! : 4) ?? Foo.DEF!));
	io::printfn("7:%s", catch? ((3 < 2 ? Foo.ABC! : 4) ?? Foo.DEF!));
	long x = Foo.DEF! ?? 3;
	io::printfn("8:%s", x);
	int! xy = Foo.ABC! ?? Foo.DEF!;
}

fn int! get_a(int x)
{
	if (x % 2) return Foo.ABC!;
	return x * 2;
}

fn int! get_b(int x)
{
	if (x % 2 == 0) return Foo.ABC!;
	return x * 2;
}

/* #expect: test.ll

define void @test.main() #0 {
entry:
  %retparam = alloca i64, align 8
  %varargslots = alloca [1 x %variant], align 16
  %retparam1 = alloca i32, align 4
  %retparam2 = alloca i32, align 4
  %taddr = alloca i32, align 4
  %retparam10 = alloca i64, align 8
  %varargslots11 = alloca [1 x %variant], align 16
  %retparam12 = alloca i32, align 4
  %retparam16 = alloca i32, align 4
  %taddr24 = alloca i32, align 4
  %retparam27 = alloca i64, align 8
  %varargslots28 = alloca [1 x %variant], align 16
  %retparam29 = alloca i32, align 4
  %retparam33 = alloca i32, align 4
  %taddr41 = alloca i32, align 4
  %retparam44 = alloca i64, align 8
  %varargslots45 = alloca [1 x %variant], align 16
  %taddr46 = alloca i64, align 8
  %retparam49 = alloca i64, align 8
  %varargslots50 = alloca [1 x %variant], align 16
  %taddr51 = alloca i32, align 4
  %retparam54 = alloca i64, align 8
  %varargslots55 = alloca [1 x %variant], align 16
  %taddr56 = alloca i64, align 8
  %retparam59 = alloca i64, align 8
  %varargslots60 = alloca [1 x %variant], align 16
  %error_var = alloca i64, align 8
  %x = alloca i64, align 8
  %retparam65 = alloca i64, align 8
  %varargslots66 = alloca [1 x %variant], align 16
  %xy = alloca i32, align 4
  %xy.f = alloca i64, align 8
  %0 = call i64 @test.get_a(ptr %retparam1, i32 1)
  %not_err = icmp eq i64 %0, 0
  %1 = call i1 @llvm.expect.i1(i1 %not_err, i1 true)
  br i1 %1, label %after_check, label %else_block

after_check:                                      ; preds = %entry
  %2 = load i32, ptr %retparam1, align 4
  br label %phi_block

else_block:                                       ; preds = %entry
  %3 = call i64 @test.get_b(ptr %retparam2, i32 4)
  %not_err3 = icmp eq i64 %3, 0
  %4 = call i1 @llvm.expect.i1(i1 %not_err3, i1 true)
  br i1 %4, label %after_check4, label %else_block5

after_check4:                                     ; preds = %else_block
  %5 = load i32, ptr %retparam2, align 4
  br label %phi_block

phi_block:                                        ; preds = %after_check4, %after_check
  %val = phi i32 [ %2, %after_check ], [ %5, %after_check4 ]
  br label %phi_block6

else_block5:                                      ; preds = %else_block
  br label %phi_block6

phi_block6:                                       ; preds = %else_block5, %phi_block
  %val7 = phi i32 [ %val, %phi_block ], [ -1, %else_block5 ]
  store i32 %val7, ptr %taddr, align 4
  %6 = insertvalue %variant undef, ptr %taddr, 0
  %7 = insertvalue %variant %6, i64 ptrtoint (ptr @"$ct.int" to i64), 1
  %8 = getelementptr inbounds [1 x %variant], ptr %varargslots, i64 0, i64 0
  store %variant %7, ptr %8, align 16
  %9 = call i64 @std.io.printfn(ptr %retparam, ptr @.str, i64 4, ptr %varargslots, i64 1)
  %10 = call i64 @test.get_a(ptr %retparam12, i32 2)
  %not_err13 = icmp eq i64 %10, 0
  %11 = call i1 @llvm.expect.i1(i1 %not_err13, i1 true)
  br i1 %11, label %after_check14, label %else_block15

after_check14:                                    ; preds = %phi_block6
  %12 = load i32, ptr %retparam12, align 4
  br label %phi_block19

else_block15:                                     ; preds = %phi_block6
  %13 = call i64 @test.get_b(ptr %retparam16, i32 4)
  %not_err17 = icmp eq i64 %13, 0
  %14 = call i1 @llvm.expect.i1(i1 %not_err17, i1 true)
  br i1 %14, label %after_check18, label %else_block21

after_check18:                                    ; preds = %else_block15
  %15 = load i32, ptr %retparam16, align 4
  br label %phi_block19

phi_block19:                                      ; preds = %after_check18, %after_check14
  %val20 = phi i32 [ %12, %after_check14 ], [ %15, %after_check18 ]
  br label %phi_block22

else_block21:                                     ; preds = %else_block15
  br label %phi_block22

phi_block22:                                      ; preds = %else_block21, %phi_block19
  %val23 = phi i32 [ %val20, %phi_block19 ], [ -1, %else_block21 ]
  store i32 %val23, ptr %taddr24, align 4
  %16 = insertvalue %variant undef, ptr %taddr24, 0
  %17 = insertvalue %variant %16, i64 ptrtoint (ptr @"$ct.int" to i64), 1
  %18 = getelementptr inbounds [1 x %variant], ptr %varargslots11, i64 0, i64 0
  store %variant %17, ptr %18, align 16
  %19 = call i64 @std.io.printfn(ptr %retparam10, ptr @.str.2, i64 4, ptr %varargslots11, i64 1)
  %20 = call i64 @test.get_a(ptr %retparam29, i32 1)
  %not_err30 = icmp eq i64 %20, 0
  %21 = call i1 @llvm.expect.i1(i1 %not_err30, i1 true)
  br i1 %21, label %after_check31, label %else_block32

after_check31:                                    ; preds = %phi_block22
  %22 = load i32, ptr %retparam29, align 4
  br label %phi_block36

else_block32:                                     ; preds = %phi_block22
  %23 = call i64 @test.get_b(ptr %retparam33, i32 5)
  %not_err34 = icmp eq i64 %23, 0
  %24 = call i1 @llvm.expect.i1(i1 %not_err34, i1 true)
  br i1 %24, label %after_check35, label %else_block38

after_check35:                                    ; preds = %else_block32
  %25 = load i32, ptr %retparam33, align 4
  br label %phi_block36

phi_block36:                                      ; preds = %after_check35, %after_check31
  %val37 = phi i32 [ %22, %after_check31 ], [ %25, %after_check35 ]
  br label %phi_block39

else_block38:                                     ; preds = %else_block32
  br label %phi_block39

phi_block39:                                      ; preds = %else_block38, %phi_block36
  %val40 = phi i32 [ %val37, %phi_block36 ], [ -1, %else_block38 ]
  store i32 %val40, ptr %taddr41, align 4
  %26 = insertvalue %variant undef, ptr %taddr41, 0
  %27 = insertvalue %variant %26, i64 ptrtoint (ptr @"$ct.int" to i64), 1
  %28 = getelementptr inbounds [1 x %variant], ptr %varargslots28, i64 0, i64 0
  store %variant %27, ptr %28, align 16
  %29 = call i64 @std.io.printfn(ptr %retparam27, ptr @.str.3, i64 4, ptr %varargslots28, i64 1)
  store i64 ptrtoint (ptr @"test.Foo$DEF" to i64), ptr %taddr46, align 8
  %30 = insertvalue %variant undef, ptr %taddr46, 0
  %31 = insertvalue %variant %30, i64 ptrtoint (ptr @"$ct.anyerr" to i64), 1
  %32 = getelementptr inbounds [1 x %variant], ptr %varargslots45, i64 0, i64 0
  store %variant %31, ptr %32, align 16
  %33 = call i64 @std.io.printfn(ptr %retparam44, ptr @.str.4, i64 4, ptr %varargslots45, i64 1)
  store i32 3, ptr %taddr51, align 4
  %34 = insertvalue %variant undef, ptr %taddr51, 0
  %35 = insertvalue %variant %34, i64 ptrtoint (ptr @"$ct.int" to i64), 1
  %36 = getelementptr inbounds [1 x %variant], ptr %varargslots50, i64 0, i64 0
  store %variant %35, ptr %36, align 16
  %37 = call i64 @std.io.printfn(ptr %retparam49, ptr @.str.5, i64 4, ptr %varargslots50, i64 1)
  store i64 ptrtoint (ptr @"test.Foo$DEF" to i64), ptr %taddr56, align 8
  %38 = insertvalue %variant undef, ptr %taddr56, 0
  %39 = insertvalue %variant %38, i64 ptrtoint (ptr @"$ct.anyerr" to i64), 1
  %40 = getelementptr inbounds [1 x %variant], ptr %varargslots55, i64 0, i64 0
  store %variant %39, ptr %40, align 16
  %41 = call i64 @std.io.printfn(ptr %retparam54, ptr @.str.6, i64 4, ptr %varargslots55, i64 1)
  store i64 0, ptr %error_var, align 8
  br label %phi_block62

phi_block62:                                      ; preds = %phi_block39
  br label %noerr_block

noerr_block:                                      ; preds = %phi_block62
  %42 = insertvalue %variant undef, ptr %error_var, 0
  %43 = insertvalue %variant %42, i64 ptrtoint (ptr @"$ct.anyerr" to i64), 1
  %44 = getelementptr inbounds [1 x %variant], ptr %varargslots60, i64 0, i64 0
  store %variant %43, ptr %44, align 16
  %45 = call i64 @std.io.printfn(ptr %retparam59, ptr @.str.7, i64 4, ptr %varargslots60, i64 1)
  store i64 3, ptr %x, align 8
  %46 = insertvalue %variant undef, ptr %x, 0
  %47 = insertvalue %variant %46, i64 ptrtoint (ptr @"$ct.long" to i64), 1
  %48 = getelementptr inbounds [1 x %variant], ptr %varargslots66, i64 0, i64 0
  store %variant %47, ptr %48, align 16
  %49 = call i64 @std.io.printfn(ptr %retparam65, ptr @.str.8, i64 4, ptr %varargslots66, i64 1)
  store i64 ptrtoint (ptr @"test.Foo$DEF" to i64), ptr %xy.f, align 8
  ret void
}

; Function Attrs: nounwind
define i64 @test.get_a(ptr %0, i32 %1) #0 {
entry:
  %reterr = alloca i64, align 8
  %smod = srem i32 %1, 2
  %intbool = icmp ne i32 %smod, 0
  br i1 %intbool, label %if.then, label %if.exit

if.then:                                          ; preds = %entry
  ret i64 ptrtoint (ptr @"test.Foo$ABC" to i64)

if.exit:                                          ; preds = %entry
  %mul = mul i32 %1, 2
  store i32 %mul, ptr %0, align 4
  ret i64 0
}

; Function Attrs: nounwind
define i64 @test.get_b(ptr %0, i32 %1) #0 {
entry:
  %reterr = alloca i64, align 8
  %smod = srem i32 %1, 2
  %eq = icmp eq i32 %smod, 0
  br i1 %eq, label %if.then, label %if.exit

if.then:                                          ; preds = %entry
  ret i64 ptrtoint (ptr @"test.Foo$ABC" to i64)

if.exit:                                          ; preds = %entry
  %mul = mul i32 %1, 2
  store i32 %mul, ptr %0, align 4
  ret i64 0
}