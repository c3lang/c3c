// #target: macos-x64
module test;
import std;
import libc;

struct Doc { Head *head; }
struct Head { char[]* title; }

struct Summary
{
	char[]* title;
	bool ok;
}

fn void Summary.print(Summary *s, CFile out)
{
	// We don't have a native printf in C3 yet, so use libc,
	// which is not all that nice for the strings but...
	char[] title = s.title ? *s.title : "missing";
	libc::fprintf(out, "Summary({ .title = %.*s, .ok = %s})", (int)title.len, title.ptr, s.ok ? (char*)"true" : (char*)"false");
}

fn bool contains(char[] haystack, char[] needle)
{
	usz len = haystack.len;
	usz needle_len = needle.len;
	if (len < needle_len) return false;
	if (!needle_len) return true;
	len -= needle_len - 1;
	for (usz i = 0; i < len; i++)
	{
		if (libc::memcmp(&haystack[i], needle.ptr, needle_len) == 0)
		{
			return true;
		}
	}
	return false;
}

macro dupe(value)
{
	$typeof(&value) temp = malloc($sizeof(value));
	if (!temp) return ReadError.OUT_OF_MEMORY?;
	*temp = value;
	return temp;
}

fault ReadError
{
	BAD_READ,
	OUT_OF_MEMORY
}

fn Doc! readDoc(char[] url)
{
	if (contains(url, "fail")) return ReadError.BAD_READ?;
	if (contains(url, "head-missing")) return { .head = null };
	if (contains(url, "title-missing")) return { dupe(Head { .title = null })! };
	if (contains(url, "title-empty")) return { dupe(Head { .title = dupe((char[])"")! })! };
	// Not particularly elegant due to missing string functions.
	int len = libc::snprintf(null, 0, "Title of %.*s", (int)url.len, url.ptr);
	char* str = malloc(len + 1);
	if (!str) return ReadError.OUT_OF_MEMORY?;
	libc::snprintf(str, len + 1, "Title of %.*s", (int)url.len, url.ptr);
	return { dupe(Head { .title = dupe(str[..len - 1])! })! };
}

fn Summary buildSummary(Doc doc)
{
    return Summary {
        .title = doc.head ? doc.head.title : null,
        .ok = true,
    };
}

fn Summary readAndBuildSummary(char[] url)
{
	return buildSummary(readDoc(url)) ?? Summary { .title = null, .ok = false };
	/*
	// or
	Summary summary = buildSummary(readDoc(url));
	if (catch summary) return Summary { .title = null, .ok = false };
	return summary;
	// or
	Summary summary = buildSummary(readDoc(url));
	if (try summary) return summary;
	return Summary { .title = null, .ok = false };
	*/
}


fault TitleResult
{
	TITLE_MISSING
}

fn bool! isTitleNonEmpty(Doc doc)
{
	if (!doc.head) return TitleResult.TITLE_MISSING?;
	char[]* head = doc.head.title;
	if (!head) return TitleResult.TITLE_MISSING?;
	return (*head).len > 0;
}


fn bool! readWhetherTitleNonEmpty(char[] url)
{
    return isTitleNonEmpty(readDoc(url));
}

fn char* bool_to_string(bool b)
{
	return b ? "true" : "false";
}
fn char* nameFromError(anyfault e)
{
	switch (e)
	{
		case TitleResult.TITLE_MISSING:
			return "no title";
		case ReadError.BAD_READ:
			return "bad read";
		case ReadError.OUT_OF_MEMORY:
			return "out of memory";
		default:
			return "unknown error";
	}
}


fn void main()
{
    const char[][] URLS = { "good", "title-empty", "title-missing", "head-missing", "fail" };
    foreach (char[] url : URLS)
    {
        // Yes, it's pretty onerous to print strings for the moment in C3
        libc::printf(`Checking "https://%.*s/":` "\n", (int)url.len, url.ptr);
        Summary summary = readAndBuildSummary(url);
        libc::printf("  Summary: ");
        summary.print(libc::stdout());
        libc::printf("\n");
        char[] title_sure = summary.title ? *summary.title : "";
        libc::printf("  Title: %.*s\n", (int)title_sure.len, title_sure.ptr);
        bool! has_title = readWhetherTitleNonEmpty(url);
        // This looks a bit less than elegant, but as you see it's mostly due to having to
        // use printf here.
        libc::printf("  Has title: %s vs %s\n", bool_to_string(has_title) ?? nameFromError(@catchof(has_title)), (has_title ?? false) ? (char*)"true" : (char*)"false");
    }
}

/* #expect: test.ll

define void @test.Summary.print(ptr %0, ptr %1) #0 {
entry:
  %title = alloca %"char[]", align 8
  %2 = getelementptr inbounds %Summary, ptr %0, i32 0, i32 0
  %3 = load ptr, ptr %2, align 8
  %ptrbool = icmp ne ptr %3, null
  br i1 %ptrbool, label %cond.lhs, label %cond.rhs

cond.lhs:                                         ; preds = %entry
  %4 = getelementptr inbounds %Summary, ptr %0, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = load %"char[]", ptr %5, align 8
  br label %cond.phi

cond.rhs:                                         ; preds = %entry
  br label %cond.phi

cond.phi:                                         ; preds = %cond.rhs, %cond.lhs
  %val = phi %"char[]" [ %6, %cond.lhs ], [ { ptr @.str.26, i64 7 }, %cond.rhs ]
  store %"char[]" %val, ptr %title, align 8
  %7 = getelementptr inbounds %"char[]", ptr %title, i32 0, i32 1
  %8 = load i64, ptr %7, align 8
  %trunc = trunc i64 %8 to i32
  %9 = getelementptr inbounds %"char[]", ptr %title, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr inbounds %Summary, ptr %0, i32 0, i32 1
  %12 = load i8, ptr %11, align 8
  %13 = trunc i8 %12 to i1
  %ternary = select i1 %13, ptr @.str.28, ptr @.str.29
  %14 = call i32 (ptr, ptr, ...) @fprintf(ptr %1, ptr @.str.27, i32 %trunc, ptr %10, ptr %ternary)
  ret void
}

; Function Attrs: nounwind
define zeroext i8 @test.contains(ptr %0, i64 %1, ptr %2, i64 %3) #0 {
entry:
  %haystack = alloca %"char[]", align 8
  %needle = alloca %"char[]", align 8
  %len = alloca i64, align 8
  %needle_len = alloca i64, align 8
  %i = alloca i64, align 8
  store ptr %0, ptr %haystack, align 8
  %ptroffset = getelementptr inbounds i64, ptr %haystack, i64 1
  store i64 %1, ptr %ptroffset, align 8
  store ptr %2, ptr %needle, align 8
  %ptroffset1 = getelementptr inbounds i64, ptr %needle, i64 1
  store i64 %3, ptr %ptroffset1, align 8
  %4 = getelementptr inbounds %"char[]", ptr %haystack, i32 0, i32 1
  %5 = load i64, ptr %4, align 8
  store i64 %5, ptr %len, align 8
  %6 = getelementptr inbounds %"char[]", ptr %needle, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  store i64 %7, ptr %needle_len, align 8
  %8 = load i64, ptr %len, align 8
  %9 = load i64, ptr %needle_len, align 8
  %lt = icmp ult i64 %8, %9
  br i1 %lt, label %if.then, label %if.exit

if.then:                                          ; preds = %entry
  ret i8 0

if.exit:                                          ; preds = %entry
  %10 = load i64, ptr %needle_len, align 8
  %not = icmp eq i64 %10, 0
  br i1 %not, label %if.then2, label %if.exit3

if.then2:                                         ; preds = %if.exit
  ret i8 1

if.exit3:                                         ; preds = %if.exit
  %11 = load i64, ptr %len, align 8
  %12 = load i64, ptr %needle_len, align 8
  %sub = sub i64 %12, 1
  %sub4 = sub i64 %11, %sub
  store i64 %sub4, ptr %len, align 8
  store i64 0, ptr %i, align 8
  br label %loop.cond

loop.cond:                                        ; preds = %if.exit8, %if.exit3
  %13 = load i64, ptr %i, align 8
  %14 = load i64, ptr %len, align 8
  %lt5 = icmp ult i64 %13, %14
  br i1 %lt5, label %loop.body, label %loop.exit

loop.body:                                        ; preds = %loop.cond
  %15 = getelementptr inbounds %"char[]", ptr %haystack, i32 0, i32 0
  %16 = load ptr, ptr %15, align 8
  %17 = load i64, ptr %i, align 8
  %ptroffset6 = getelementptr inbounds i8, ptr %16, i64 %17
  %18 = getelementptr inbounds %"char[]", ptr %needle, i32 0, i32 0
  %19 = load ptr, ptr %18, align 8
  %20 = load i64, ptr %needle_len, align 8
  %21 = call i32 @memcmp(ptr %ptroffset6, ptr %19, i64 %20)
  %eq = icmp eq i32 %21, 0
  br i1 %eq, label %if.then7, label %if.exit8

if.then7:                                         ; preds = %loop.body
  ret i8 1

if.exit8:                                         ; preds = %loop.body
  %22 = load i64, ptr %i, align 8
  %add = add i64 %22, 1
  store i64 %add, ptr %i, align 8
  br label %loop.cond

loop.exit:                                        ; preds = %loop.cond
  ret i8 0
}

; Function Attrs: nounwind
define i64 @test.readDoc(ptr %0, ptr %1, i64 %2) #0 {
entry:
  %url = alloca %"char[]", align 8
  %reterr = alloca i64, align 8
  %literal = alloca %Doc, align 8
  %reterr8 = alloca i64, align 8
  %literal9 = alloca %Doc, align 8
  %error_var = alloca i64, align 8
  %value = alloca %Head, align 8
  %literal10 = alloca %Head, align 8
  %temp = alloca ptr, align 8
  %using = alloca ptr, align 8
  %end_padding = alloca i64, align 8
  %error_var11 = alloca i64, align 8
  %using12 = alloca ptr, align 8
  %end_padding13 = alloca i64, align 8
  %.anon = alloca i64, align 8
  %allocator = alloca ptr, align 8
  %size = alloca i64, align 8
  %retparam = alloca ptr, align 8
  %varargslots = alloca [1 x %any], align 16
  %indirectarg = alloca %"any[]", align 8
  %reterr23 = alloca i64, align 8
  %literal24 = alloca %Doc, align 8
  %error_var25 = alloca i64, align 8
  %value26 = alloca %Head, align 8
  %literal27 = alloca %Head, align 8
  %error_var28 = alloca i64, align 8
  %value29 = alloca %"char[]", align 8
  %temp30 = alloca ptr, align 8
  %using31 = alloca ptr, align 8
  %end_padding32 = alloca i64, align 8
  %error_var33 = alloca i64, align 8
  %using34 = alloca ptr, align 8
  %end_padding35 = alloca i64, align 8
  %.anon36 = alloca i64, align 8
  %allocator38 = alloca ptr, align 8
  %size39 = alloca i64, align 8
  %retparam42 = alloca ptr, align 8
  %varargslots47 = alloca [1 x %any], align 16
  %indirectarg48 = alloca %"any[]", align 8
  %temp55 = alloca ptr, align 8
  %using56 = alloca ptr, align 8
  %end_padding57 = alloca i64, align 8
  %error_var58 = alloca i64, align 8
  %using59 = alloca ptr, align 8
  %end_padding60 = alloca i64, align 8
  %.anon61 = alloca i64, align 8
  %allocator63 = alloca ptr, align 8
  %size64 = alloca i64, align 8
  %retparam67 = alloca ptr, align 8
  %varargslots72 = alloca [1 x %any], align 16
  %indirectarg73 = alloca %"any[]", align 8
  %len = alloca i32, align 4
  %str = alloca ptr, align 8
  %using81 = alloca ptr, align 8
  %end_padding82 = alloca i64, align 8
  %error_var83 = alloca i64, align 8
  %using84 = alloca ptr, align 8
  %end_padding85 = alloca i64, align 8
  %.anon86 = alloca i32, align 4
  %allocator88 = alloca ptr, align 8
  %size89 = alloca i64, align 8
  %retparam91 = alloca ptr, align 8
  %varargslots96 = alloca [1 x %any], align 16
  %indirectarg97 = alloca %"any[]", align 8
  %reterr105 = alloca i64, align 8
  %literal106 = alloca %Doc, align 8
  %error_var107 = alloca i64, align 8
  %value108 = alloca %Head, align 8
  %literal109 = alloca %Head, align 8
  %error_var110 = alloca i64, align 8
  %value111 = alloca %"char[]", align 8
  %temp115 = alloca ptr, align 8
  %using116 = alloca ptr, align 8
  %end_padding117 = alloca i64, align 8
  %error_var118 = alloca i64, align 8
  %using119 = alloca ptr, align 8
  %end_padding120 = alloca i64, align 8
  %.anon121 = alloca i64, align 8
  %allocator123 = alloca ptr, align 8
  %size124 = alloca i64, align 8
  %retparam127 = alloca ptr, align 8
  %varargslots132 = alloca [1 x %any], align 16
  %indirectarg133 = alloca %"any[]", align 8
  %temp140 = alloca ptr, align 8
  %using141 = alloca ptr, align 8
  %end_padding142 = alloca i64, align 8
  %error_var143 = alloca i64, align 8
  %using144 = alloca ptr, align 8
  %end_padding145 = alloca i64, align 8
  %.anon146 = alloca i64, align 8
  %allocator148 = alloca ptr, align 8
  %size149 = alloca i64, align 8
  %retparam152 = alloca ptr, align 8
  %varargslots157 = alloca [1 x %any], align 16
  %indirectarg158 = alloca %"any[]", align 8
  store ptr %1, ptr %url, align 8
  %ptroffset = getelementptr inbounds i64, ptr %url, i64 1
  store i64 %2, ptr %ptroffset, align 8
  %3 = getelementptr inbounds %"char[]", ptr %url, i32 0, i32 0
  %lo = load ptr, ptr %3, align 8
  %4 = getelementptr inbounds %"char[]", ptr %url, i32 0, i32 1
  %hi = load i64, ptr %4, align 8
  %5 = call i8 @test.contains(ptr %lo, i64 %hi, ptr @.str, i64 4)
  %6 = trunc i8 %5 to i1
  br i1 %6, label %if.then, label %if.exit

if.then:                                          ; preds = %entry
  ret i64 ptrtoint (ptr @"test.ReadError$BAD_READ" to i64)

if.exit:                                          ; preds = %entry
  %7 = getelementptr inbounds %"char[]", ptr %url, i32 0, i32 0
  %lo1 = load ptr, ptr %7, align 8
  %8 = getelementptr inbounds %"char[]", ptr %url, i32 0, i32 1
  %hi2 = load i64, ptr %8, align 8
  %9 = call i8 @test.contains(ptr %lo1, i64 %hi2, ptr @.str.3, i64 12)
  %10 = trunc i8 %9 to i1
  br i1 %10, label %if.then3, label %if.exit4

if.then3:                                         ; preds = %if.exit
  %11 = getelementptr inbounds %Doc, ptr %literal, i32 0, i32 0
  store ptr null, ptr %11, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %0, ptr align 8 %literal, i32 8, i1 false)
  ret i64 0

if.exit4:                                         ; preds = %if.exit
  %12 = getelementptr inbounds %"char[]", ptr %url, i32 0, i32 0
  %lo5 = load ptr, ptr %12, align 8
  %13 = getelementptr inbounds %"char[]", ptr %url, i32 0, i32 1
  %hi6 = load i64, ptr %13, align 8
  %14 = call i8 @test.contains(ptr %lo5, i64 %hi6, ptr @.str.4, i64 13)
  %15 = trunc i8 %14 to i1
  br i1 %15, label %if.then7, label %if.exit19

if.then7:                                         ; preds = %if.exit4
  %16 = getelementptr inbounds %Doc, ptr %literal9, i32 0, i32 0
  %17 = getelementptr inbounds %Head, ptr %literal10, i32 0, i32 0
  store ptr null, ptr %17, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %value, ptr align 8 %literal10, i32 8, i1 false)
  %18 = load ptr, ptr @std.core.mem.thread_allocator, align 8
  store ptr %18, ptr %using, align 8
  store i64 0, ptr %end_padding, align 8
  %19 = load ptr, ptr %using, align 8
  store ptr %19, ptr %using12, align 8
  %20 = load i64, ptr %end_padding, align 8
  store i64 %20, ptr %end_padding13, align 8
  store i64 8, ptr %.anon, align 8
  %21 = load ptr, ptr %using12, align 8
  store ptr %21, ptr %allocator, align 8
  %22 = load i64, ptr %.anon, align 8
  %23 = load i64, ptr %end_padding13, align 8
  %add = add i64 %22, %23
  store i64 %add, ptr %size, align 8
  %24 = load ptr, ptr %allocator, align 8
  %25 = getelementptr inbounds %Allocator, ptr %24, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  %27 = load ptr, ptr %allocator, align 8
  %28 = load i64, ptr %size, align 8
  %29 = call i64 %26(ptr %retparam, ptr %27, i64 %28, i64 0, i64 0, ptr null, i32 0)
  %not_err = icmp eq i64 %29, 0
  %30 = call i1 @llvm.expect.i1(i1 %not_err, i1 true)
  br i1 %30, label %after_check, label %assign_optional

assign_optional:                                  ; preds = %if.then7
  store i64 %29, ptr %error_var11, align 8
  br label %panic_block

after_check:                                      ; preds = %if.then7
  %31 = load ptr, ptr %retparam, align 8
  br label %noerr_block

panic_block:                                      ; preds = %assign_optional
  %32 = insertvalue %any undef, ptr %error_var11, 0
  %33 = insertvalue %any %32, i64 ptrtoint (ptr @"$ct.anyfault" to i64), 1
  %34 = getelementptr inbounds [1 x %any], ptr %varargslots, i64 0, i64 0
  store %any %33, ptr %34, align 16
  %35 = insertvalue %"any[]" undef, ptr %varargslots, 0
  %36 = insertvalue %"any[]" %35, i64 1, 1
  store %"any[]" %36, ptr %indirectarg, align 8
  call void @std.core.builtin.panicf(ptr @.panic_msg, i64 36, ptr @.file, i64 6, ptr @.func, i64 7, i32 200, ptr byval(%"any[]") align 8 %indirectarg)
  unreachable

noerr_block:                                      ; preds = %after_check
  store ptr %31, ptr %temp, align 8
  %37 = load ptr, ptr %temp, align 8
  %not = icmp eq ptr %37, null
  br i1 %not, label %if.then16, label %if.exit17

if.then16:                                        ; preds = %noerr_block
  store i64 ptrtoint (ptr @"test.ReadError$OUT_OF_MEMORY" to i64), ptr %error_var, align 8
  br label %guard_block

if.exit17:                                        ; preds = %noerr_block
  %38 = load ptr, ptr %temp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %38, ptr align 8 %value, i32 8, i1 false)
  br label %noerr_block18

guard_block:                                      ; preds = %if.then16
  %39 = load i64, ptr %error_var, align 8
  ret i64 %39

noerr_block18:                                    ; preds = %if.exit17
  %40 = load ptr, ptr %temp, align 8
  store ptr %40, ptr %16, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %0, ptr align 8 %literal9, i32 8, i1 false)
  ret i64 0

if.exit19:                                        ; preds = %if.exit4
  %41 = getelementptr inbounds %"char[]", ptr %url, i32 0, i32 0
  %lo20 = load ptr, ptr %41, align 8
  %42 = getelementptr inbounds %"char[]", ptr %url, i32 0, i32 1
  %hi21 = load i64, ptr %42, align 8
  %43 = call i8 @test.contains(ptr %lo20, i64 %hi21, ptr @.str.5, i64 11)
  %44 = trunc i8 %43 to i1
  br i1 %44, label %if.then22, label %if.exit80

if.then22:                                        ; preds = %if.exit19
  %45 = getelementptr inbounds %Doc, ptr %literal24, i32 0, i32 0
  store ptr null, ptr %literal27, align 8
  %46 = getelementptr inbounds %Head, ptr %literal27, i32 0, i32 0
  store %"char[]" zeroinitializer, ptr %value29, align 8
  %47 = load ptr, ptr @std.core.mem.thread_allocator, align 8
  store ptr %47, ptr %using31, align 8
  store i64 0, ptr %end_padding32, align 8
  %48 = load ptr, ptr %using31, align 8
  store ptr %48, ptr %using34, align 8
  %49 = load i64, ptr %end_padding32, align 8
  store i64 %49, ptr %end_padding35, align 8
  store i64 16, ptr %.anon36, align 8
  %50 = load ptr, ptr %using34, align 8
  store ptr %50, ptr %allocator38, align 8
  %51 = load i64, ptr %.anon36, align 8
  %52 = load i64, ptr %end_padding35, align 8
  %add40 = add i64 %51, %52
  store i64 %add40, ptr %size39, align 8
  %53 = load ptr, ptr %allocator38, align 8
  %54 = getelementptr inbounds %Allocator, ptr %53, i32 0, i32 0
  %55 = load ptr, ptr %54, align 8
  %56 = load ptr, ptr %allocator38, align 8
  %57 = load i64, ptr %size39, align 8
  %58 = call i64 %55(ptr %retparam42, ptr %56, i64 %57, i64 0, i64 0, ptr null, i32 0)
  %not_err43 = icmp eq i64 %58, 0
  %59 = call i1 @llvm.expect.i1(i1 %not_err43, i1 true)
  br i1 %59, label %after_check45, label %assign_optional44

assign_optional44:                                ; preds = %if.then22
  store i64 %58, ptr %error_var33, align 8
  br label %panic_block46

after_check45:                                    ; preds = %if.then22
  %60 = load ptr, ptr %retparam42, align 8
  br label %noerr_block49

panic_block46:                                    ; preds = %assign_optional44
  %61 = insertvalue %any undef, ptr %error_var33, 0
  %62 = insertvalue %any %61, i64 ptrtoint (ptr @"$ct.anyfault" to i64), 1
  %63 = getelementptr inbounds [1 x %any], ptr %varargslots47, i64 0, i64 0
  store %any %62, ptr %63, align 16
  %64 = insertvalue %"any[]" undef, ptr %varargslots47, 0
  %65 = insertvalue %"any[]" %64, i64 1, 1
  store %"any[]" %65, ptr %indirectarg48, align 8
  call void @std.core.builtin.panicf(ptr @.panic_msg, i64 36, ptr @.file, i64 6, ptr @.func, i64 7, i32 200, ptr byval(%"any[]") align 8 %indirectarg48)
  unreachable

noerr_block49:                                    ; preds = %after_check45
  store ptr %60, ptr %temp30, align 8
  %66 = load ptr, ptr %temp30, align 8
  %not50 = icmp eq ptr %66, null
  br i1 %not50, label %if.then51, label %if.exit52

if.then51:                                        ; preds = %noerr_block49
  store i64 ptrtoint (ptr @"test.ReadError$OUT_OF_MEMORY" to i64), ptr %error_var28, align 8
  br label %guard_block53

if.exit52:                                        ; preds = %noerr_block49
  %67 = load ptr, ptr %temp30, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %67, ptr align 8 %value29, i32 16, i1 false)
  br label %noerr_block54

guard_block53:                                    ; preds = %if.then51
  %68 = load i64, ptr %error_var28, align 8
  ret i64 %68

noerr_block54:                                    ; preds = %if.exit52
  %69 = load ptr, ptr %temp30, align 8
  store ptr %69, ptr %46, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %value26, ptr align 8 %literal27, i32 8, i1 false)
  %70 = load ptr, ptr @std.core.mem.thread_allocator, align 8
  store ptr %70, ptr %using56, align 8
  store i64 0, ptr %end_padding57, align 8
  %71 = load ptr, ptr %using56, align 8
  store ptr %71, ptr %using59, align 8
  %72 = load i64, ptr %end_padding57, align 8
  store i64 %72, ptr %end_padding60, align 8
  store i64 8, ptr %.anon61, align 8
  %73 = load ptr, ptr %using59, align 8
  store ptr %73, ptr %allocator63, align 8
  %74 = load i64, ptr %.anon61, align 8
  %75 = load i64, ptr %end_padding60, align 8
  %add65 = add i64 %74, %75
  store i64 %add65, ptr %size64, align 8
  %76 = load ptr, ptr %allocator63, align 8
  %77 = getelementptr inbounds %Allocator, ptr %76, i32 0, i32 0
  %78 = load ptr, ptr %77, align 8
  %79 = load ptr, ptr %allocator63, align 8
  %80 = load i64, ptr %size64, align 8
  %81 = call i64 %78(ptr %retparam67, ptr %79, i64 %80, i64 0, i64 0, ptr null, i32 0)
  %not_err68 = icmp eq i64 %81, 0
  %82 = call i1 @llvm.expect.i1(i1 %not_err68, i1 true)
  br i1 %82, label %after_check70, label %assign_optional69

assign_optional69:                                ; preds = %noerr_block54
  store i64 %81, ptr %error_var58, align 8
  br label %panic_block71

after_check70:                                    ; preds = %noerr_block54
  %83 = load ptr, ptr %retparam67, align 8
  br label %noerr_block74

panic_block71:                                    ; preds = %assign_optional69
  %84 = insertvalue %any undef, ptr %error_var58, 0
  %85 = insertvalue %any %84, i64 ptrtoint (ptr @"$ct.anyfault" to i64), 1
  %86 = getelementptr inbounds [1 x %any], ptr %varargslots72, i64 0, i64 0
  store %any %85, ptr %86, align 16
  %87 = insertvalue %"any[]" undef, ptr %varargslots72, 0
  %88 = insertvalue %"any[]" %87, i64 1, 1
  store %"any[]" %88, ptr %indirectarg73, align 8
  call void @std.core.builtin.panicf(ptr @.panic_msg, i64 36, ptr @.file, i64 6, ptr @.func, i64 7, i32 200, ptr byval(%"any[]") align 8 %indirectarg73)
  unreachable

noerr_block74:                                    ; preds = %after_check70
  store ptr %83, ptr %temp55, align 8
  %89 = load ptr, ptr %temp55, align 8
  %not75 = icmp eq ptr %89, null
  br i1 %not75, label %if.then76, label %if.exit77

if.then76:                                        ; preds = %noerr_block74
  store i64 ptrtoint (ptr @"test.ReadError$OUT_OF_MEMORY" to i64), ptr %error_var25, align 8
  br label %guard_block78

if.exit77:                                        ; preds = %noerr_block74
  %90 = load ptr, ptr %temp55, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %90, ptr align 8 %value26, i32 8, i1 false)
  br label %noerr_block79

guard_block78:                                    ; preds = %if.then76
  %91 = load i64, ptr %error_var25, align 8
  ret i64 %91

noerr_block79:                                    ; preds = %if.exit77
  %92 = load ptr, ptr %temp55, align 8
  store ptr %92, ptr %45, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %0, ptr align 8 %literal24, i32 8, i1 false)
  ret i64 0

if.exit80:                                        ; preds = %if.exit19
  %93 = getelementptr inbounds %"char[]", ptr %url, i32 0, i32 1
  %94 = load i64, ptr %93, align 8
  %trunc = trunc i64 %94 to i32
  %95 = getelementptr inbounds %"char[]", ptr %url, i32 0, i32 0
  %96 = load ptr, ptr %95, align 8
  %97 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr null, i64 0, ptr @.str.6, i32 %trunc, ptr %96)
  store i32 %97, ptr %len, align 4
  %98 = load ptr, ptr @std.core.mem.thread_allocator, align 8
  store ptr %98, ptr %using81, align 8
  store i64 0, ptr %end_padding82, align 8
  %99 = load ptr, ptr %using81, align 8
  store ptr %99, ptr %using84, align 8
  %100 = load i64, ptr %end_padding82, align 8
  store i64 %100, ptr %end_padding85, align 8
  %101 = load i32, ptr %len, align 4
  %add87 = add i32 %101, 1
  store i32 %add87, ptr %.anon86, align 4
  %102 = load ptr, ptr %using84, align 8
  store ptr %102, ptr %allocator88, align 8
  %103 = load i32, ptr %.anon86, align 4
  %sext = sext i32 %103 to i64
  %104 = load i64, ptr %end_padding85, align 8
  %add90 = add i64 %sext, %104
  store i64 %add90, ptr %size89, align 8
  %105 = load ptr, ptr %allocator88, align 8
  %106 = getelementptr inbounds %Allocator, ptr %105, i32 0, i32 0
  %107 = load ptr, ptr %106, align 8
  %108 = load ptr, ptr %allocator88, align 8
  %109 = load i64, ptr %size89, align 8
  %110 = call i64 %107(ptr %retparam91, ptr %108, i64 %109, i64 0, i64 0, ptr null, i32 0)
  %not_err92 = icmp eq i64 %110, 0
  %111 = call i1 @llvm.expect.i1(i1 %not_err92, i1 true)
  br i1 %111, label %after_check94, label %assign_optional93

assign_optional93:                                ; preds = %if.exit80
  store i64 %110, ptr %error_var83, align 8
  br label %panic_block95

after_check94:                                    ; preds = %if.exit80
  %112 = load ptr, ptr %retparam91, align 8
  br label %noerr_block98

panic_block95:                                    ; preds = %assign_optional93
  %113 = insertvalue %any undef, ptr %error_var83, 0
  %114 = insertvalue %any %113, i64 ptrtoint (ptr @"$ct.anyfault" to i64), 1
  %115 = getelementptr inbounds [1 x %any], ptr %varargslots96, i64 0, i64 0
  store %any %114, ptr %115, align 16
  %116 = insertvalue %"any[]" undef, ptr %varargslots96, 0
  %117 = insertvalue %"any[]" %116, i64 1, 1
  store %"any[]" %117, ptr %indirectarg97, align 8
  call void @std.core.builtin.panicf(ptr @.panic_msg, i64 36, ptr @.file, i64 6, ptr @.func, i64 7, i32 200, ptr byval(%"any[]") align 8 %indirectarg97)
  unreachable

noerr_block98:                                    ; preds = %after_check94
  store ptr %112, ptr %str, align 8
  %118 = load ptr, ptr %str, align 8
  %not99 = icmp eq ptr %118, null
  br i1 %not99, label %if.then100, label %if.exit101

if.then100:                                       ; preds = %noerr_block98
  ret i64 ptrtoint (ptr @"test.ReadError$OUT_OF_MEMORY" to i64)

if.exit101:                                       ; preds = %noerr_block98
  %119 = load ptr, ptr %str, align 8
  %120 = load i32, ptr %len, align 4
  %sext102 = sext i32 %120 to i64
  %add103 = add i64 %sext102, 1
  %121 = getelementptr inbounds %"char[]", ptr %url, i32 0, i32 1
  %122 = load i64, ptr %121, align 8
  %trunc104 = trunc i64 %122 to i32
  %123 = getelementptr inbounds %"char[]", ptr %url, i32 0, i32 0
  %124 = load ptr, ptr %123, align 8
  %125 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr %119, i64 %add103, ptr @.str.7, i32 %trunc104, ptr %124)
  %126 = getelementptr inbounds %Doc, ptr %literal106, i32 0, i32 0
  store ptr null, ptr %literal109, align 8
  %127 = getelementptr inbounds %Head, ptr %literal109, i32 0, i32 0
  %128 = load ptr, ptr %str, align 8
  %129 = load i32, ptr %len, align 4
  %sub = sub i32 %129, 1
  %sext112 = sext i32 %sub to i64
  %130 = add i64 %sext112, 1
  %size113 = sub i64 %130, 0
  %ptroffset114 = getelementptr inbounds i8, ptr %128, i64 0
  %131 = insertvalue %"char[]" undef, ptr %ptroffset114, 0
  %132 = insertvalue %"char[]" %131, i64 %size113, 1
  store %"char[]" %132, ptr %value111, align 8
  %133 = load ptr, ptr @std.core.mem.thread_allocator, align 8
  store ptr %133, ptr %using116, align 8
  store i64 0, ptr %end_padding117, align 8
  %134 = load ptr, ptr %using116, align 8
  store ptr %134, ptr %using119, align 8
  %135 = load i64, ptr %end_padding117, align 8
  store i64 %135, ptr %end_padding120, align 8
  store i64 16, ptr %.anon121, align 8
  %136 = load ptr, ptr %using119, align 8
  store ptr %136, ptr %allocator123, align 8
  %137 = load i64, ptr %.anon121, align 8
  %138 = load i64, ptr %end_padding120, align 8
  %add125 = add i64 %137, %138
  store i64 %add125, ptr %size124, align 8
  %139 = load ptr, ptr %allocator123, align 8
  %140 = getelementptr inbounds %Allocator, ptr %139, i32 0, i32 0
  %141 = load ptr, ptr %140, align 8
  %142 = load ptr, ptr %allocator123, align 8
  %143 = load i64, ptr %size124, align 8
  %144 = call i64 %141(ptr %retparam127, ptr %142, i64 %143, i64 0, i64 0, ptr null, i32 0)
  %not_err128 = icmp eq i64 %144, 0
  %145 = call i1 @llvm.expect.i1(i1 %not_err128, i1 true)
  br i1 %145, label %after_check130, label %assign_optional129

assign_optional129:                               ; preds = %if.exit101
  store i64 %144, ptr %error_var118, align 8
  br label %panic_block131

after_check130:                                   ; preds = %if.exit101
  %146 = load ptr, ptr %retparam127, align 8
  br label %noerr_block134

panic_block131:                                   ; preds = %assign_optional129
  %147 = insertvalue %any undef, ptr %error_var118, 0
  %148 = insertvalue %any %147, i64 ptrtoint (ptr @"$ct.anyfault" to i64), 1
  %149 = getelementptr inbounds [1 x %any], ptr %varargslots132, i64 0, i64 0
  store %any %148, ptr %149, align 16
  %150 = insertvalue %"any[]" undef, ptr %varargslots132, 0
  %151 = insertvalue %"any[]" %150, i64 1, 1
  store %"any[]" %151, ptr %indirectarg133, align 8
  call void @std.core.builtin.panicf(ptr @.panic_msg, i64 36, ptr @.file, i64 6, ptr @.func, i64 7, i32 200, ptr byval(%"any[]") align 8 %indirectarg133)
  unreachable

noerr_block134:                                   ; preds = %after_check130
  store ptr %146, ptr %temp115, align 8
  %152 = load ptr, ptr %temp115, align 8
  %not135 = icmp eq ptr %152, null
  br i1 %not135, label %if.then136, label %if.exit137

if.then136:                                       ; preds = %noerr_block134
  store i64 ptrtoint (ptr @"test.ReadError$OUT_OF_MEMORY" to i64), ptr %error_var110, align 8
  br label %guard_block138

if.exit137:                                       ; preds = %noerr_block134
  %153 = load ptr, ptr %temp115, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %153, ptr align 8 %value111, i32 16, i1 false)
  br label %noerr_block139

guard_block138:                                   ; preds = %if.then136
  %154 = load i64, ptr %error_var110, align 8
  ret i64 %154

noerr_block139:                                   ; preds = %if.exit137
  %155 = load ptr, ptr %temp115, align 8
  store ptr %155, ptr %127, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %value108, ptr align 8 %literal109, i32 8, i1 false)
  %156 = load ptr, ptr @std.core.mem.thread_allocator, align 8
  store ptr %156, ptr %using141, align 8
  store i64 0, ptr %end_padding142, align 8
  %157 = load ptr, ptr %using141, align 8
  store ptr %157, ptr %using144, align 8
  %158 = load i64, ptr %end_padding142, align 8
  store i64 %158, ptr %end_padding145, align 8
  store i64 8, ptr %.anon146, align 8
  %159 = load ptr, ptr %using144, align 8
  store ptr %159, ptr %allocator148, align 8
  %160 = load i64, ptr %.anon146, align 8
  %161 = load i64, ptr %end_padding145, align 8
  %add150 = add i64 %160, %161
  store i64 %add150, ptr %size149, align 8
  %162 = load ptr, ptr %allocator148, align 8
  %163 = getelementptr inbounds %Allocator, ptr %162, i32 0, i32 0
  %164 = load ptr, ptr %163, align 8
  %165 = load ptr, ptr %allocator148, align 8
  %166 = load i64, ptr %size149, align 8
  %167 = call i64 %164(ptr %retparam152, ptr %165, i64 %166, i64 0, i64 0, ptr null, i32 0)
  %not_err153 = icmp eq i64 %167, 0
  %168 = call i1 @llvm.expect.i1(i1 %not_err153, i1 true)
  br i1 %168, label %after_check155, label %assign_optional154

assign_optional154:                               ; preds = %noerr_block139
  store i64 %167, ptr %error_var143, align 8
  br label %panic_block156

after_check155:                                   ; preds = %noerr_block139
  %169 = load ptr, ptr %retparam152, align 8
  br label %noerr_block159

panic_block156:                                   ; preds = %assign_optional154
  %170 = insertvalue %any undef, ptr %error_var143, 0
  %171 = insertvalue %any %170, i64 ptrtoint (ptr @"$ct.anyfault" to i64), 1
  %172 = getelementptr inbounds [1 x %any], ptr %varargslots157, i64 0, i64 0
  store %any %171, ptr %172, align 16
  %173 = insertvalue %"any[]" undef, ptr %varargslots157, 0
  %174 = insertvalue %"any[]" %173, i64 1, 1
  store %"any[]" %174, ptr %indirectarg158, align 8
  call void @std.core.builtin.panicf(ptr @.panic_msg, i64 36, ptr @.file, i64 6, ptr @.func, i64 7, i32 200, ptr byval(%"any[]") align 8 %indirectarg158)
  unreachable

noerr_block159:                                   ; preds = %after_check155
  store ptr %169, ptr %temp140, align 8
  %175 = load ptr, ptr %temp140, align 8
  %not160 = icmp eq ptr %175, null
  br i1 %not160, label %if.then161, label %if.exit162

if.then161:                                       ; preds = %noerr_block159
  store i64 ptrtoint (ptr @"test.ReadError$OUT_OF_MEMORY" to i64), ptr %error_var107, align 8
  br label %guard_block163

if.exit162:                                       ; preds = %noerr_block159
  %176 = load ptr, ptr %temp140, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %176, ptr align 8 %value108, i32 8, i1 false)
  br label %noerr_block164

guard_block163:                                   ; preds = %if.then161
  %177 = load i64, ptr %error_var107, align 8
  ret i64 %177

noerr_block164:                                   ; preds = %if.exit162
  %178 = load ptr, ptr %temp140, align 8
  store ptr %178, ptr %126, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %0, ptr align 8 %literal106, i32 8, i1 false)
  ret i64 0
}

; Function Attrs: nounwind
define { ptr, i8 } @test.buildSummary(ptr %0) #0 {
entry:
  %doc = alloca %Doc, align 8
  %literal = alloca %Summary, align 8
  store ptr %0, ptr %doc, align 8
  %1 = getelementptr inbounds %Summary, ptr %literal, i32 0, i32 0
  store ptr null, ptr %1, align 8
  %2 = getelementptr inbounds %Summary, ptr %literal, i32 0, i32 1
  store i8 0, ptr %2, align 8
  %3 = getelementptr inbounds %Summary, ptr %literal, i32 0, i32 0
  %4 = getelementptr inbounds %Doc, ptr %doc, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %ptrbool = icmp ne ptr %5, null
  br i1 %ptrbool, label %cond.lhs, label %cond.rhs

cond.lhs:                                         ; preds = %entry
  %6 = getelementptr inbounds %Doc, ptr %doc, i32 0, i32 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds %Head, ptr %7, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  br label %cond.phi

cond.rhs:                                         ; preds = %entry
  br label %cond.phi

cond.phi:                                         ; preds = %cond.rhs, %cond.lhs
  %val = phi ptr [ %9, %cond.lhs ], [ null, %cond.rhs ]
  store ptr %val, ptr %3, align 8
  %10 = getelementptr inbounds %Summary, ptr %literal, i32 0, i32 1
  store i8 1, ptr %10, align 8
  %11 = load { ptr, i8 }, ptr %literal, align 8
  ret { ptr, i8 } %11
}

; Function Attrs: nounwind
define { ptr, i8 } @test.readAndBuildSummary(ptr %0, i64 %1) #0 {
entry:
  %url = alloca %"char[]", align 8
  %retparam = alloca %Doc, align 8
  %result = alloca %Summary, align 8
  %literal = alloca %Summary, align 8
  %taddr = alloca %Summary, align 8
  store ptr %0, ptr %url, align 8
  %ptroffset = getelementptr inbounds i64, ptr %url, i64 1
  store i64 %1, ptr %ptroffset, align 8
  %2 = getelementptr inbounds %"char[]", ptr %url, i32 0, i32 0
  %lo = load ptr, ptr %2, align 8
  %3 = getelementptr inbounds %"char[]", ptr %url, i32 0, i32 1
  %hi = load i64, ptr %3, align 8
  %4 = call i64 @test.readDoc(ptr %retparam, ptr %lo, i64 %hi)
  %not_err = icmp eq i64 %4, 0
  %5 = call i1 @llvm.expect.i1(i1 %not_err, i1 true)
  br i1 %5, label %after_check, label %else_block

after_check:                                      ; preds = %entry
  %6 = load ptr, ptr %retparam, align 8
  %7 = call { ptr, i8 } @test.buildSummary(ptr %6)
  store { ptr, i8 } %7, ptr %result, align 8
  %8 = load %Summary, ptr %result, align 8
  br label %phi_block

else_block:                                       ; preds = %entry
  %9 = getelementptr inbounds %Summary, ptr %literal, i32 0, i32 0
  store ptr null, ptr %9, align 8
  %10 = getelementptr inbounds %Summary, ptr %literal, i32 0, i32 1
  store i8 0, ptr %10, align 8
  %11 = load %Summary, ptr %literal, align 8
  br label %phi_block

phi_block:                                        ; preds = %else_block, %after_check
  %val = phi %Summary [ %8, %after_check ], [ %11, %else_block ]
  store %Summary %val, ptr %taddr, align 8
  %12 = load { ptr, i8 }, ptr %taddr, align 8
  ret { ptr, i8 } %12
}

; Function Attrs: nounwind
define i64 @test.isTitleNonEmpty(ptr %0, ptr %1) #0 {
entry:
  %doc = alloca %Doc, align 8
  %head = alloca ptr, align 8
  %reterr = alloca i64, align 8
  store ptr %1, ptr %doc, align 8
  %2 = getelementptr inbounds %Doc, ptr %doc, i32 0, i32 0
  %3 = load ptr, ptr %2, align 8
  %not = icmp eq ptr %3, null
  br i1 %not, label %if.then, label %if.exit

if.then:                                          ; preds = %entry
  ret i64 ptrtoint (ptr @"test.TitleResult$TITLE_MISSING" to i64)

if.exit:                                          ; preds = %entry
  %4 = getelementptr inbounds %Doc, ptr %doc, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds %Head, ptr %5, i32 0, i32 0
  %7 = load ptr, ptr %6, align 8
  store ptr %7, ptr %head, align 8
  %8 = load ptr, ptr %head, align 8
  %not1 = icmp eq ptr %8, null
  br i1 %not1, label %if.then2, label %if.exit3

if.then2:                                         ; preds = %if.exit
  ret i64 ptrtoint (ptr @"test.TitleResult$TITLE_MISSING" to i64)

if.exit3:                                         ; preds = %if.exit
  %9 = load ptr, ptr %head, align 8
  %10 = getelementptr inbounds %"char[]", ptr %9, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  %lt = icmp ult i64 0, %11
  %12 = zext i1 %lt to i8
  store i8 %12, ptr %0, align 1
  ret i64 0
}

; Function Attrs: nounwind
define i64 @test.readWhetherTitleNonEmpty(ptr %0, ptr %1, i64 %2) #0 {
entry:
  %url = alloca %"char[]", align 8
  %reterr = alloca i64, align 8
  %retparam = alloca i8, align 1
  %retparam1 = alloca %Doc, align 8
  store ptr %1, ptr %url, align 8
  %ptroffset = getelementptr inbounds i64, ptr %url, i64 1
  store i64 %2, ptr %ptroffset, align 8
  %3 = getelementptr inbounds %"char[]", ptr %url, i32 0, i32 0
  %lo = load ptr, ptr %3, align 8
  %4 = getelementptr inbounds %"char[]", ptr %url, i32 0, i32 1
  %hi = load i64, ptr %4, align 8
  %5 = call i64 @test.readDoc(ptr %retparam1, ptr %lo, i64 %hi)
  %not_err = icmp eq i64 %5, 0
  %6 = call i1 @llvm.expect.i1(i1 %not_err, i1 true)
  br i1 %6, label %after_check, label %assign_optional

assign_optional:                                  ; preds = %entry
  store i64 %5, ptr %reterr, align 8
  br label %err_retblock

after_check:                                      ; preds = %entry
  %7 = load ptr, ptr %retparam1, align 8
  %8 = call i64 @test.isTitleNonEmpty(ptr %retparam, ptr %7)
  %not_err2 = icmp eq i64 %8, 0
  %9 = call i1 @llvm.expect.i1(i1 %not_err2, i1 true)
  br i1 %9, label %after_check4, label %assign_optional3

assign_optional3:                                 ; preds = %after_check
  store i64 %8, ptr %reterr, align 8
  br label %err_retblock

after_check4:                                     ; preds = %after_check
  %10 = load i8, ptr %retparam, align 1
  store i8 %10, ptr %0, align 1
  ret i64 0

err_retblock:                                     ; preds = %assign_optional3, %assign_optional
  %11 = load i64, ptr %reterr, align 8
  ret i64 %11
}

; Function Attrs: nounwind
define ptr @test.bool_to_string(i8 zeroext %0) #0 {
entry:
  %1 = trunc i8 %0 to i1
  %ternary = select i1 %1, %"char[]" { ptr @.str.8, i64 4 }, %"char[]" { ptr @.str.9, i64 5 }
  %2 = extractvalue %"char[]" %ternary, 0
  ret ptr %2
}

; Function Attrs: nounwind
define ptr @test.nameFromError(i64 %0) #0 {
entry:
  %switch = alloca i64, align 8
  store i64 %0, ptr %switch, align 8
  br label %switch.entry

switch.entry:                                     ; preds = %entry
  %1 = load i64, ptr %switch, align 8
  %eq = icmp eq i64 ptrtoint (ptr @"test.TitleResult$TITLE_MISSING" to i64), %1
  br i1 %eq, label %switch.case, label %next_if

switch.case:                                      ; preds = %switch.entry
  ret ptr @.str.10

next_if:                                          ; preds = %switch.entry
  %eq1 = icmp eq i64 ptrtoint (ptr @"test.ReadError$BAD_READ" to i64), %1
  br i1 %eq1, label %switch.case2, label %next_if3

switch.case2:                                     ; preds = %next_if
  ret ptr @.str.11

next_if3:                                         ; preds = %next_if
  %eq4 = icmp eq i64 ptrtoint (ptr @"test.ReadError$OUT_OF_MEMORY" to i64), %1
  br i1 %eq4, label %switch.case5, label %next_if6

switch.case5:                                     ; preds = %next_if3
  ret ptr @.str.12

next_if6:                                         ; preds = %next_if3
  br label %switch.default

switch.default:                                   ; preds = %next_if6
  ret ptr @.str.13
}

; Function Attrs: nounwind
define void @test.main() #0 {
entry:
  %URLS = alloca %"char[][]", align 8
  %literal = alloca [5 x %"char[]"], align 16
  %.anon = alloca i64, align 8
  %.anon1 = alloca i64, align 8
  %url = alloca %"char[]", align 8
  %summary = alloca %Summary, align 8
  %result = alloca %Summary, align 8
  %title_sure = alloca %"char[]", align 8
  %has_title = alloca i8, align 1
  %has_title.f = alloca i64, align 8
  %retparam = alloca i8, align 1
  %blockret = alloca i64, align 8
  %f = alloca i64, align 8
  %0 = getelementptr inbounds [5 x %"char[]"], ptr %literal, i64 0, i64 0
  store %"char[]" { ptr @.str.14, i64 4 }, ptr %0, align 8
  %1 = getelementptr inbounds [5 x %"char[]"], ptr %literal, i64 0, i64 1
  store %"char[]" { ptr @.str.15, i64 11 }, ptr %1, align 8
  %2 = getelementptr inbounds [5 x %"char[]"], ptr %literal, i64 0, i64 2
  store %"char[]" { ptr @.str.16, i64 13 }, ptr %2, align 8
  %3 = getelementptr inbounds [5 x %"char[]"], ptr %literal, i64 0, i64 3
  store %"char[]" { ptr @.str.17, i64 12 }, ptr %3, align 8
  %4 = getelementptr inbounds [5 x %"char[]"], ptr %literal, i64 0, i64 4
  store %"char[]" { ptr @.str.18, i64 4 }, ptr %4, align 8
  %5 = insertvalue %"char[][]" undef, ptr %literal, 0
  %6 = insertvalue %"char[][]" %5, i64 5, 1
  store %"char[][]" %6, ptr %URLS, align 8
  %7 = getelementptr inbounds %"char[][]", ptr %URLS, i32 0, i32 1
  %8 = load i64, ptr %7, align 8
  store i64 %8, ptr %.anon, align 8
  store i64 0, ptr %.anon1, align 8
  br label %loop.cond

loop.cond:                                        ; preds = %phi_block16, %entry
  %9 = load i64, ptr %.anon1, align 8
  %10 = load i64, ptr %.anon, align 8
  %lt = icmp ult i64 %9, %10
  br i1 %lt, label %loop.body, label %loop.exit

loop.body:                                        ; preds = %loop.cond
  %11 = getelementptr inbounds %"char[][]", ptr %URLS, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  %13 = load i64, ptr %.anon1, align 8
  %ptroffset = getelementptr inbounds %"char[]", ptr %12, i64 %13
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %url, ptr align 8 %ptroffset, i32 16, i1 false)
  %14 = getelementptr inbounds %"char[]", ptr %url, i32 0, i32 1
  %15 = load i64, ptr %14, align 8
  %trunc = trunc i64 %15 to i32
  %16 = getelementptr inbounds %"char[]", ptr %url, i32 0, i32 0
  %17 = load ptr, ptr %16, align 8
  %18 = call i32 (ptr, ...) @printf(ptr @.str.19, i32 %trunc, ptr %17)
  %19 = getelementptr inbounds %"char[]", ptr %url, i32 0, i32 0
  %lo = load ptr, ptr %19, align 8
  %20 = getelementptr inbounds %"char[]", ptr %url, i32 0, i32 1
  %hi = load i64, ptr %20, align 8
  %21 = call { ptr, i8 } @test.readAndBuildSummary(ptr %lo, i64 %hi)
  store { ptr, i8 } %21, ptr %result, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %summary, ptr align 8 %result, i32 16, i1 false)
  %22 = call i32 (ptr, ...) @printf(ptr @.str.20)
  %23 = load ptr, ptr @__stdoutp, align 8
  call void @test.Summary.print(ptr %summary, ptr %23)
  %24 = call i32 (ptr, ...) @printf(ptr @.str.21)
  %25 = getelementptr inbounds %Summary, ptr %summary, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  %ptrbool = icmp ne ptr %26, null
  br i1 %ptrbool, label %cond.lhs, label %cond.rhs

cond.lhs:                                         ; preds = %loop.body
  %27 = getelementptr inbounds %Summary, ptr %summary, i32 0, i32 0
  %28 = load ptr, ptr %27, align 8
  %29 = load %"char[]", ptr %28, align 8
  br label %cond.phi

cond.rhs:                                         ; preds = %loop.body
  br label %cond.phi

cond.phi:                                         ; preds = %cond.rhs, %cond.lhs
  %val = phi %"char[]" [ %29, %cond.lhs ], [ zeroinitializer, %cond.rhs ]
  store %"char[]" %val, ptr %title_sure, align 8
  %30 = getelementptr inbounds %"char[]", ptr %title_sure, i32 0, i32 1
  %31 = load i64, ptr %30, align 8
  %trunc2 = trunc i64 %31 to i32
  %32 = getelementptr inbounds %"char[]", ptr %title_sure, i32 0, i32 0
  %33 = load ptr, ptr %32, align 8
  %34 = call i32 (ptr, ...) @printf(ptr @.str.22, i32 %trunc2, ptr %33)
  %35 = getelementptr inbounds %"char[]", ptr %url, i32 0, i32 0
  %lo3 = load ptr, ptr %35, align 8
  %36 = getelementptr inbounds %"char[]", ptr %url, i32 0, i32 1
  %hi4 = load i64, ptr %36, align 8
  %37 = call i64 @test.readWhetherTitleNonEmpty(ptr %retparam, ptr %lo3, i64 %hi4)
  %not_err = icmp eq i64 %37, 0
  %38 = call i1 @llvm.expect.i1(i1 %not_err, i1 true)
  br i1 %38, label %after_check, label %assign_optional

assign_optional:                                  ; preds = %cond.phi
  store i64 %37, ptr %has_title.f, align 8
  br label %after_assign

after_check:                                      ; preds = %cond.phi
  %39 = load i8, ptr %retparam, align 1
  store i8 %39, ptr %has_title, align 1
  store i64 0, ptr %has_title.f, align 8
  br label %after_assign

after_assign:                                     ; preds = %after_check, %assign_optional
  %optval = load i64, ptr %has_title.f, align 8
  %not_err5 = icmp eq i64 %optval, 0
  %40 = call i1 @llvm.expect.i1(i1 %not_err5, i1 true)
  br i1 %40, label %after_check6, label %else_block

after_check6:                                     ; preds = %after_assign
  %41 = load i8, ptr %has_title, align 1
  %42 = call ptr @test.bool_to_string(i8 zeroext %41)
  br label %phi_block

else_block:                                       ; preds = %after_assign
  br label %testblock

testblock:                                        ; preds = %else_block
  %optval7 = load i64, ptr %has_title.f, align 8
  %not_err8 = icmp eq i64 %optval7, 0
  %43 = call i1 @llvm.expect.i1(i1 %not_err8, i1 true)
  br i1 %43, label %after_check10, label %assign_optional9

assign_optional9:                                 ; preds = %testblock
  store i64 %optval7, ptr %f, align 8
  br label %end_block

after_check10:                                    ; preds = %testblock
  store i64 0, ptr %f, align 8
  br label %end_block

end_block:                                        ; preds = %after_check10, %assign_optional9
  %44 = load i64, ptr %f, align 8
  %neq = icmp ne i64 %44, 0
  br i1 %neq, label %if.then, label %if.exit

if.then:                                          ; preds = %end_block
  %45 = load i64, ptr %f, align 8
  store i64 %45, ptr %blockret, align 8
  br label %expr_block.exit

if.exit:                                          ; preds = %end_block
  store i64 0, ptr %blockret, align 8
  br label %expr_block.exit

expr_block.exit:                                  ; preds = %if.exit, %if.then
  %46 = load i64, ptr %blockret, align 8
  %47 = call ptr @test.nameFromError(i64 %46)
  br label %phi_block

phi_block:                                        ; preds = %expr_block.exit, %after_check6
  %val11 = phi ptr [ %42, %after_check6 ], [ %47, %expr_block.exit ]
  %optval12 = load i64, ptr %has_title.f, align 8
  %not_err13 = icmp eq i64 %optval12, 0
  %48 = call i1 @llvm.expect.i1(i1 %not_err13, i1 true)
  br i1 %48, label %after_check14, label %else_block15

after_check14:                                    ; preds = %phi_block
  %49 = load i8, ptr %has_title, align 1
  %50 = trunc i8 %49 to i1
  br label %phi_block16

else_block15:                                     ; preds = %phi_block
  br label %phi_block16

phi_block16:                                      ; preds = %else_block15, %after_check14
  %val17 = phi i1 [ %50, %after_check14 ], [ false, %else_block15 ]
  %ternary = select i1 %val17, ptr @.str.24, ptr @.str.25
  %51 = call i32 (ptr, ...) @printf(ptr @.str.23, ptr %val11, ptr %ternary)
  %52 = load i64, ptr %.anon1, align 8
  %add = add i64 %52, 1
  store i64 %add, ptr %.anon1, align 8
  br label %loop.cond

loop.exit:                                        ; preds = %loop.cond
  ret void
}
