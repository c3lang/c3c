// #target: macos-x64
module foo;
import std::io;

fault Foo { ABC }

fn void blurb() { io::printn("Blurb");}

macro int! tester()
{
	defer blurb();
	return Foo.ABC!;
}
fn void! test(int x)
{
	io::printfn("test(%d)", x);
	if (x || (tester()?)) io::printn("Ok1");
	io::printn("Test next");
	if (tester()? || x) io::printn("Ok?");
	io::printn("Test ok");
}

fn void! test2(int x)
{
	io::printfn("test2(%d)", x);
	if (x && (tester()?)) io::printn("Ok1");
	io::printn("Test next");
	if ((tester()?) && x) io::printn("Ok?");
	io::printn("Test ok");
}

fn void main()
{
	anyerr a = test(0);
	anyerr b = test(1);
	anyerr c = test2(0);
	anyerr d = test2(1);
}

/* #expect: foo.ll

define i64 @foo.test(i32 %0) #0 {
entry:
  %retparam = alloca i64, align 8
  %varargslots = alloca [1 x %variant], align 16
  %taddr = alloca i32, align 4
  %error_var = alloca i64, align 8
  %blockret = alloca i32, align 4
  %x = alloca ptr, align 8
  %retparam1 = alloca i64, align 8
  %result = alloca %File, align 8
  %x2 = alloca ptr, align 8
  %retparam3 = alloca i64, align 8
  %result4 = alloca %File, align 8
  %error_var5 = alloca i64, align 8
  %blockret6 = alloca i32, align 4
  %x10 = alloca ptr, align 8
  %retparam11 = alloca i64, align 8
  %result12 = alloca %File, align 8
  %x14 = alloca ptr, align 8
  %retparam15 = alloca i64, align 8
  %result16 = alloca %File, align 8
  %reterr = alloca i64, align 8
  store i32 %0, ptr %taddr, align 4
  %1 = insertvalue %variant undef, ptr %taddr, 0
  %2 = insertvalue %variant %1, i64 ptrtoint (ptr @"$ct.int" to i64), 1
  %3 = getelementptr inbounds [1 x %variant], ptr %varargslots, i64 0, i64 0
  store %variant %2, ptr %3, align 16
  %4 = call i64 @std.io.printfn(ptr %retparam, ptr @.str.1, i64 8, ptr %varargslots, i64 1)
  %intbool = icmp ne i32 %0, 0
  br i1 %intbool, label %or.phi, label %or.rhs

or.rhs:                                           ; preds = %entry
  store i64 ptrtoint (ptr @"foo.Foo$ABC" to i64), ptr %error_var, align 8
  br label %opt_block_cleanup

opt_block_cleanup:                                ; preds = %or.rhs
  call void @foo.blurb()
  br label %guard_block

guard_block:                                      ; preds = %opt_block_cleanup
  %5 = load i64, ptr %error_var, align 8
  ret i64 %5

or.phi:                                           ; preds = %entry
  br label %if.then

if.then:                                          ; preds = %or.phi
  store ptr @.str.2, ptr %x, align 8
  %6 = call ptr @std.io.stdout()
  store ptr %6, ptr %result, align 8
  %7 = load ptr, ptr %result, align 8
  %8 = load ptr, ptr %x, align 8
  %9 = call i64 @std.io.File.printn(ptr %retparam1, ptr %7, ptr %8, i64 3)
  br label %if.exit

if.exit:                                          ; preds = %if.then
  store ptr @.str.3, ptr %x2, align 8
  %10 = call ptr @std.io.stdout()
  store ptr %10, ptr %result4, align 8
  %11 = load ptr, ptr %result4, align 8
  %12 = load ptr, ptr %x2, align 8
  %13 = call i64 @std.io.File.printn(ptr %retparam3, ptr %11, ptr %12, i64 9)
  store i64 ptrtoint (ptr @"foo.Foo$ABC" to i64), ptr %error_var5, align 8
  br label %opt_block_cleanup7

opt_block_cleanup7:                               ; preds = %if.exit
  call void @foo.blurb()
  br label %guard_block8

guard_block8:                                     ; preds = %opt_block_cleanup7
  %14 = load i64, ptr %error_var5, align 8
  ret i64 %14

if.exit13:                                        ; No predecessors!
  store ptr @.str.5, ptr %x14, align 8
  %15 = call ptr @std.io.stdout()
  store ptr %15, ptr %result16, align 8
  %16 = load ptr, ptr %result16, align 8
  %17 = load ptr, ptr %x14, align 8
  %18 = call i64 @std.io.File.printn(ptr %retparam15, ptr %16, ptr %17, i64 7)
  ret i64 0
}

; Function Attrs: nounwind
define i64 @foo.test2(i32 %0) #0 {
entry:
  %retparam = alloca i64, align 8
  %varargslots = alloca [1 x %variant], align 16
  %taddr = alloca i32, align 4
  %error_var = alloca i64, align 8
  %blockret = alloca i32, align 4
  %x = alloca ptr, align 8
  %retparam1 = alloca i64, align 8
  %result = alloca %File, align 8
  %error_var2 = alloca i64, align 8
  %blockret3 = alloca i32, align 4
  %x7 = alloca ptr, align 8
  %retparam8 = alloca i64, align 8
  %result9 = alloca %File, align 8
  %reterr = alloca i64, align 8
  store i32 %0, ptr %taddr, align 4
  %1 = insertvalue %variant undef, ptr %taddr, 0
  %2 = insertvalue %variant %1, i64 ptrtoint (ptr @"$ct.int" to i64), 1
  %3 = getelementptr inbounds [1 x %variant], ptr %varargslots, i64 0, i64 0
  store %variant %2, ptr %3, align 16
  %4 = call i64 @std.io.printfn(ptr %retparam, ptr @.str.6, i64 9, ptr %varargslots, i64 1)
  %intbool = icmp ne i32 %0, 0
  br i1 %intbool, label %and.rhs, label %and.phi

and.rhs:                                          ; preds = %entry
  store i64 ptrtoint (ptr @"foo.Foo$ABC" to i64), ptr %error_var, align 8
  br label %opt_block_cleanup

opt_block_cleanup:                                ; preds = %and.rhs
  call void @foo.blurb()
  br label %guard_block

guard_block:                                      ; preds = %opt_block_cleanup
  %5 = load i64, ptr %error_var, align 8
  ret i64 %5

and.phi:                                          ; preds = %entry
  br label %if.exit

if.exit:                                          ; preds = %and.phi
  store ptr @.str.7, ptr %x, align 8
  %6 = call ptr @std.io.stdout()
  store ptr %6, ptr %result, align 8
  %7 = load ptr, ptr %result, align 8
  %8 = load ptr, ptr %x, align 8
  %9 = call i64 @std.io.File.printn(ptr %retparam1, ptr %7, ptr %8, i64 9)
  store i64 ptrtoint (ptr @"foo.Foo$ABC" to i64), ptr %error_var2, align 8
  br label %opt_block_cleanup4

opt_block_cleanup4:                               ; preds = %if.exit
  call void @foo.blurb()
  br label %guard_block5

guard_block5:                                     ; preds = %opt_block_cleanup4
  %10 = load i64, ptr %error_var2, align 8
  ret i64 %10

if.exit6:                                         ; No predecessors!
  store ptr @.str.8, ptr %x7, align 8
  %11 = call ptr @std.io.stdout()
  store ptr %11, ptr %result9, align 8
  %12 = load ptr, ptr %result9, align 8
  %13 = load ptr, ptr %x7, align 8
  %14 = call i64 @std.io.File.printn(ptr %retparam8, ptr %12, ptr %13, i64 7)
  ret i64 0
}

; Function Attrs: nounwind
define void @foo.main() #0 {
entry:
  %a = alloca i64, align 8
  %error_var = alloca i64, align 8
  %b = alloca i64, align 8
  %error_var1 = alloca i64, align 8
  %c = alloca i64, align 8
  %error_var6 = alloca i64, align 8
  %d = alloca i64, align 8
  %error_var11 = alloca i64, align 8
  store i64 0, ptr %error_var, align 8
  %0 = call i64 @foo.test(i32 0)
  %not_err = icmp eq i64 %0, 0
  %1 = call i1 @llvm.expect.i1(i1 %not_err, i1 true)
  br i1 %1, label %after_check, label %assign_optional

assign_optional:                                  ; preds = %entry
  store i64 %0, ptr %error_var, align 8
  br label %noerr_block

after_check:                                      ; preds = %entry
  br label %noerr_block

noerr_block:                                      ; preds = %after_check, %assign_optional
  %2 = load i64, ptr %error_var, align 8
  store i64 %2, ptr %a, align 8
  store i64 0, ptr %error_var1, align 8
  %3 = call i64 @foo.test(i32 1)
  %not_err2 = icmp eq i64 %3, 0
  %4 = call i1 @llvm.expect.i1(i1 %not_err2, i1 true)
  br i1 %4, label %after_check4, label %assign_optional3

assign_optional3:                                 ; preds = %noerr_block
  store i64 %3, ptr %error_var1, align 8
  br label %noerr_block5

after_check4:                                     ; preds = %noerr_block
  br label %noerr_block5

noerr_block5:                                     ; preds = %after_check4, %assign_optional3
  %5 = load i64, ptr %error_var1, align 8
  store i64 %5, ptr %b, align 8
  store i64 0, ptr %error_var6, align 8
  %6 = call i64 @foo.test2(i32 0)
  %not_err7 = icmp eq i64 %6, 0
  %7 = call i1 @llvm.expect.i1(i1 %not_err7, i1 true)
  br i1 %7, label %after_check9, label %assign_optional8

assign_optional8:                                 ; preds = %noerr_block5
  store i64 %6, ptr %error_var6, align 8
  br label %noerr_block10

after_check9:                                     ; preds = %noerr_block5
  br label %noerr_block10

noerr_block10:                                    ; preds = %after_check9, %assign_optional8
  %8 = load i64, ptr %error_var6, align 8
  store i64 %8, ptr %c, align 8
  store i64 0, ptr %error_var11, align 8
  %9 = call i64 @foo.test2(i32 1)
  %not_err12 = icmp eq i64 %9, 0
  %10 = call i1 @llvm.expect.i1(i1 %not_err12, i1 true)
  br i1 %10, label %after_check14, label %assign_optional13

assign_optional13:                                ; preds = %noerr_block10
  store i64 %9, ptr %error_var11, align 8
  br label %noerr_block15

after_check14:                                    ; preds = %noerr_block10
  br label %noerr_block15

noerr_block15:                                    ; preds = %after_check14, %assign_optional13
  %11 = load i64, ptr %error_var11, align 8
  store i64 %11, ptr %d, align 8
  ret void
}

; Function Attrs: nounwind
define i32 @main(i32 %0, ptr %1) #0 {
entry:
  %.anon = alloca i32, align 4
  %.anon1 = alloca ptr, align 8
  store i32 %0, ptr %.anon, align 4
  store ptr %1, ptr %.anon1, align 8
  call void @foo.main()
  ret i32 0
}
