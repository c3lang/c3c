// #target: macos-x64
module foo;
import std::io;

fault Foo { ABC }

fn void blurb() { io::printn("Blurb");}

macro int! tester()
{
	defer blurb();
	return Foo.ABC?;
}
fn void! test(int x)
{
	io::printfn("test(%d)", x);
	if (x || (tester()!)) io::printn("Ok1");
	io::printn("Test next");
	if (tester()! || x) io::printn("Ok?");
	io::printn("Test ok");
}

fn void! test2(int x)
{
	io::printfn("test2(%d)", x);
	if (x && (tester()!)) io::printn("Ok1");
	io::printn("Test next");
	if ((tester()!) && x) io::printn("Ok?");
	io::printn("Test ok");
}

fn void main()
{
	anyfault a = test(0);
	anyfault b = test(1);
	anyfault c = test2(0);
	anyfault d = test2(1);
}

/* #expect: foo.ll

define i64 @foo.test(i32 %0) #0 {
entry:
  %retparam = alloca i64, align 8
  %varargslots = alloca [1 x %any], align 16
  %taddr = alloca i32, align 4
  %error_var = alloca i64, align 8
  %blockret = alloca i32, align 4
  %retparam1 = alloca i64, align 8
  %result = alloca %File, align 8
  %retparam2 = alloca i64, align 8
  %result3 = alloca %File, align 8
  %error_var4 = alloca i64, align 8
  %blockret5 = alloca i32, align 4
  %retparam9 = alloca i64, align 8
  %result10 = alloca %File, align 8
  %retparam12 = alloca i64, align 8
  %result13 = alloca %File, align 8
  store i32 %0, ptr %taddr, align 4
  %1 = insertvalue %any undef, ptr %taddr, 0
  %2 = insertvalue %any %1, i64 ptrtoint (ptr @"$ct.int" to i64), 1
  %3 = getelementptr inbounds [1 x %any], ptr %varargslots, i64 0, i64 0
  store %any %2, ptr %3, align 16
  %4 = call i64 @std.io.printfn(ptr %retparam, ptr @.str.1, i64 8, ptr %varargslots, i64 1)
  %intbool = icmp ne i32 %0, 0
  br i1 %intbool, label %or.phi, label %or.rhs

or.rhs:                                           ; preds = %entry
  store i64 ptrtoint (ptr @"foo.Foo$ABC" to i64), ptr %error_var, align 8
  br label %opt_block_cleanup

opt_block_cleanup:                                ; preds = %or.rhs
  call void @foo.blurb()
  br label %guard_block

guard_block:                                      ; preds = %opt_block_cleanup
  %5 = load i64, ptr %error_var, align 8
  ret i64 %5

or.phi:                                           ; preds = %entry
  br label %if.then

if.then:                                          ; preds = %or.phi
  %6 = call ptr @std.io.stdout()
  store ptr %6, ptr %result, align 8
  %7 = load ptr, ptr %result, align 8
  %8 = call i64 @std.io.File.printn(ptr %retparam1, ptr %7, ptr @.str.2, i64 3)
  br label %if.exit

if.exit:                                          ; preds = %if.then
  %9 = call ptr @std.io.stdout()
  store ptr %9, ptr %result3, align 8
  %10 = load ptr, ptr %result3, align 8
  %11 = call i64 @std.io.File.printn(ptr %retparam2, ptr %10, ptr @.str.3, i64 9)
  store i64 ptrtoint (ptr @"foo.Foo$ABC" to i64), ptr %error_var4, align 8
  br label %opt_block_cleanup6

opt_block_cleanup6:                               ; preds = %if.exit
  call void @foo.blurb()
  br label %guard_block7

guard_block7:                                     ; preds = %opt_block_cleanup6
  %12 = load i64, ptr %error_var4, align 8
  ret i64 %12

if.exit11:                                        ; No predecessors!
  %13 = call ptr @std.io.stdout()
  store ptr %13, ptr %result13, align 8
  %14 = load ptr, ptr %result13, align 8
  %15 = call i64 @std.io.File.printn(ptr %retparam12, ptr %14, ptr @.str.5, i64 7)
  ret i64 0
}

; Function Attrs: nounwind
define i64 @foo.test2(i32 %0) #0 {
entry:
  %retparam = alloca i64, align 8
  %varargslots = alloca [1 x %any], align 16
  %taddr = alloca i32, align 4
  %error_var = alloca i64, align 8
  %blockret = alloca i32, align 4
  %retparam1 = alloca i64, align 8
  %result = alloca %File, align 8
  %error_var2 = alloca i64, align 8
  %blockret3 = alloca i32, align 4
  %retparam7 = alloca i64, align 8
  %result8 = alloca %File, align 8
  store i32 %0, ptr %taddr, align 4
  %1 = insertvalue %any undef, ptr %taddr, 0
  %2 = insertvalue %any %1, i64 ptrtoint (ptr @"$ct.int" to i64), 1
  %3 = getelementptr inbounds [1 x %any], ptr %varargslots, i64 0, i64 0
  store %any %2, ptr %3, align 16
  %4 = call i64 @std.io.printfn(ptr %retparam, ptr @.str.6, i64 9, ptr %varargslots, i64 1)
  %intbool = icmp ne i32 %0, 0
  br i1 %intbool, label %and.rhs, label %and.phi

and.rhs:                                          ; preds = %entry
  store i64 ptrtoint (ptr @"foo.Foo$ABC" to i64), ptr %error_var, align 8
  br label %opt_block_cleanup

opt_block_cleanup:                                ; preds = %and.rhs
  call void @foo.blurb()
  br label %guard_block

guard_block:                                      ; preds = %opt_block_cleanup
  %5 = load i64, ptr %error_var, align 8
  ret i64 %5

and.phi:                                          ; preds = %entry
  br label %if.exit

if.exit:                                          ; preds = %and.phi
  %6 = call ptr @std.io.stdout()
  store ptr %6, ptr %result, align 8
  %7 = load ptr, ptr %result, align 8
  %8 = call i64 @std.io.File.printn(ptr %retparam1, ptr %7, ptr @.str.7, i64 9)
  store i64 ptrtoint (ptr @"foo.Foo$ABC" to i64), ptr %error_var2, align 8
  br label %opt_block_cleanup4

opt_block_cleanup4:                               ; preds = %if.exit
  call void @foo.blurb()
  br label %guard_block5

guard_block5:                                     ; preds = %opt_block_cleanup4
  %9 = load i64, ptr %error_var2, align 8
  ret i64 %9

if.exit6:                                         ; No predecessors!
  %10 = call ptr @std.io.stdout()
  store ptr %10, ptr %result8, align 8
  %11 = load ptr, ptr %result8, align 8
  %12 = call i64 @std.io.File.printn(ptr %retparam7, ptr %11, ptr @.str.8, i64 7)
  ret i64 0
}

; Function Attrs: nounwind
define void @foo.main() #0 {
entry:
  %a = alloca i64, align 8
  %error_var = alloca i64, align 8
  %b = alloca i64, align 8
  %error_var1 = alloca i64, align 8
  %c = alloca i64, align 8
  %error_var6 = alloca i64, align 8
  %d = alloca i64, align 8
  %error_var11 = alloca i64, align 8
  store i64 0, ptr %error_var, align 8
  %0 = call i64 @foo.test(i32 0)
  %not_err = icmp eq i64 %0, 0
  %1 = call i1 @llvm.expect.i1(i1 %not_err, i1 true)
  br i1 %1, label %after_check, label %assign_optional

assign_optional:                                  ; preds = %entry
  store i64 %0, ptr %error_var, align 8
  br label %noerr_block

after_check:                                      ; preds = %entry
  br label %noerr_block

noerr_block:                                      ; preds = %after_check, %assign_optional
  %2 = load i64, ptr %error_var, align 8
  store i64 %2, ptr %a, align 8
  store i64 0, ptr %error_var1, align 8
  %3 = call i64 @foo.test(i32 1)
  %not_err2 = icmp eq i64 %3, 0
  %4 = call i1 @llvm.expect.i1(i1 %not_err2, i1 true)
  br i1 %4, label %after_check4, label %assign_optional3

assign_optional3:                                 ; preds = %noerr_block
  store i64 %3, ptr %error_var1, align 8
  br label %noerr_block5

after_check4:                                     ; preds = %noerr_block
  br label %noerr_block5

noerr_block5:                                     ; preds = %after_check4, %assign_optional3
  %5 = load i64, ptr %error_var1, align 8
  store i64 %5, ptr %b, align 8
  store i64 0, ptr %error_var6, align 8
  %6 = call i64 @foo.test2(i32 0)
  %not_err7 = icmp eq i64 %6, 0
  %7 = call i1 @llvm.expect.i1(i1 %not_err7, i1 true)
  br i1 %7, label %after_check9, label %assign_optional8

assign_optional8:                                 ; preds = %noerr_block5
  store i64 %6, ptr %error_var6, align 8
  br label %noerr_block10

after_check9:                                     ; preds = %noerr_block5
  br label %noerr_block10

noerr_block10:                                    ; preds = %after_check9, %assign_optional8
  %8 = load i64, ptr %error_var6, align 8
  store i64 %8, ptr %c, align 8
  store i64 0, ptr %error_var11, align 8
  %9 = call i64 @foo.test2(i32 1)
  %not_err12 = icmp eq i64 %9, 0
  %10 = call i1 @llvm.expect.i1(i1 %not_err12, i1 true)
  br i1 %10, label %after_check14, label %assign_optional13

assign_optional13:                                ; preds = %noerr_block10
  store i64 %9, ptr %error_var11, align 8
  br label %noerr_block15

after_check14:                                    ; preds = %noerr_block10
  br label %noerr_block15

noerr_block15:                                    ; preds = %after_check14, %assign_optional13
  %11 = load i64, ptr %error_var11, align 8
  store i64 %11, ptr %d, align 8
  ret void
}

; Function Attrs: nounwind
define i32 @main(i32 %0, ptr %1) #0 {
entry:
  call void @foo.main()
  ret i32 0
}
