// #target: macos-x64
module test;
import std::io;
struct Foo
{
	int a; int b;
}
fn void test(int[2] a, int[] b, int[<2>] c)
{
	io::printfln("%s %s %s", a, b, c);
}
fn void main()
{
	var $x = { { 1, 2 } };
	Foo[1] abc = (Foo[1])$x;
	Foo def = (Foo)$x[0];
	int[2][1] y = (int[2][1])$x;
	double[2][1] y2 = $x;
	io::printfln("%s %s {%s, %s}", y, y2, def.a, def.b);
	test({ 1, 2 }, { 3, 4}, { 5, 6 });
	var $a = { 2, 7 };
	test($a, $a, $a);
}

/* #expect: test.ll

entry:
  %abc = alloca [1 x %Foo], align 4
  %def = alloca %Foo, align 4
  %y = alloca [1 x [2 x i32]], align 4
  %y2 = alloca [1 x [2 x double]], align 16
  %retparam = alloca i64, align 8
  %taddr = alloca %"char[]", align 8
  %vararg = alloca %"variant[]", align 8
  %varargslots = alloca [4 x %variant], align 16
  %literal = alloca [2 x i32], align 4
  %literal3 = alloca [2 x i32], align 4
  %taddr4 = alloca %"int[]", align 8
  %taddr7 = alloca <2 x i32>, align 8
  %literal8 = alloca [2 x i32], align 4
  %literal9 = alloca [2 x i32], align 4
  %taddr10 = alloca %"int[]", align 8
  %taddr13 = alloca <2 x i32>, align 8
  %0 = bitcast [1 x %Foo]* %abc to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %0, i8* align 4 bitcast ([1 x %Foo]* @.__const to i8*), i32 8, i1 false)
  %1 = bitcast %Foo* %def to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %1, i8* align 4 bitcast (%Foo* @.__const.1 to i8*), i32 8, i1 false)
  %2 = bitcast [1 x [2 x i32]]* %y to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %2, i8* align 4 bitcast ([1 x [2 x i32]]* @.__const.2 to i8*), i32 8, i1 false)
  %3 = bitcast [1 x [2 x double]]* %y2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %3, i8* align 16 bitcast ([1 x [2 x double]]* @.__const.3 to i8*), i32 16, i1 false)
  store %"char[]" { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.4, i32 0, i32 0), i64 14 }, %"char[]"* %taddr, align 8
  %4 = bitcast %"char[]"* %taddr to { i8*, i64 }*
  %5 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %4, i32 0, i32 0
  %lo = load i8*, i8** %5, align 8
  %6 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %4, i32 0, i32 1
  %hi = load i64, i64* %6, align 8
  %7 = bitcast [1 x [2 x i32]]* %y to i8*
  %8 = insertvalue %variant undef, i8* %7, 0
  %9 = insertvalue %variant %8, i64 ptrtoint (%.introspect* @"ct$a1$a2$int" to i64), 1
  %10 = getelementptr inbounds [4 x %variant], [4 x %variant]* %varargslots, i64 0, i64 0
  store %variant %9, %variant* %10, align 16
  %11 = bitcast [1 x [2 x double]]* %y2 to i8*
  %12 = insertvalue %variant undef, i8* %11, 0
  %13 = insertvalue %variant %12, i64 ptrtoint (%.introspect* @"ct$a1$a2$double" to i64), 1
  %14 = getelementptr inbounds [4 x %variant], [4 x %variant]* %varargslots, i64 0, i64 1
  store %variant %13, %variant* %14, align 16
  %15 = getelementptr inbounds %Foo, %Foo* %def, i32 0, i32 0
  %16 = bitcast i32* %15 to i8*
  %17 = insertvalue %variant undef, i8* %16, 0
  %18 = insertvalue %variant %17, i64 ptrtoint (%.introspect* @"ct$int" to i64), 1
  %19 = getelementptr inbounds [4 x %variant], [4 x %variant]* %varargslots, i64 0, i64 2
  store %variant %18, %variant* %19, align 16
  %20 = getelementptr inbounds %Foo, %Foo* %def, i32 0, i32 1
  %21 = bitcast i32* %20 to i8*
  %22 = insertvalue %variant undef, i8* %21, 0
  %23 = insertvalue %variant %22, i64 ptrtoint (%.introspect* @"ct$int" to i64), 1
  %24 = getelementptr inbounds [4 x %variant], [4 x %variant]* %varargslots, i64 0, i64 3
  store %variant %23, %variant* %24, align 16
  %25 = getelementptr inbounds %"variant[]", %"variant[]"* %vararg, i32 0, i32 1
  store i64 4, i64* %25, align 8
  %26 = getelementptr inbounds %"variant[]", %"variant[]"* %vararg, i32 0, i32 0
  %27 = bitcast [4 x %variant]* %varargslots to %variant*
  store %variant* %27, %variant** %26, align 8
  %28 = bitcast %"variant[]"* %vararg to { i8*, i64 }*
  %29 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %28, i32 0, i32 0
  %lo1 = load i8*, i8** %29, align 8
  %30 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %28, i32 0, i32 1
  %hi2 = load i64, i64* %30, align 8
  %31 = call i64 @std_io_printfln(i64* %retparam, i8* %lo, i64 %hi, i8* %lo1, i64 %hi2)
  %not_err = icmp eq i64 %31, 0
  br i1 %not_err, label %after_check, label %voiderr

after_check:                                      ; preds = %entry
  br label %voiderr

voiderr:                                          ; preds = %after_check, %entry
  %32 = getelementptr inbounds [2 x i32], [2 x i32]* %literal, i64 0, i64 0
  store i32 1, i32* %32, align 4
  %33 = getelementptr inbounds [2 x i32], [2 x i32]* %literal, i64 0, i64 1
  store i32 2, i32* %33, align 4
  %34 = bitcast [2 x i32]* %literal to i64*
  %35 = load i64, i64* %34, align 4
  %36 = getelementptr inbounds [2 x i32], [2 x i32]* %literal3, i64 0, i64 0
  store i32 3, i32* %36, align 4
  %37 = getelementptr inbounds [2 x i32], [2 x i32]* %literal3, i64 0, i64 1
  store i32 4, i32* %37, align 4
  %38 = bitcast [2 x i32]* %literal3 to i32*
  %39 = insertvalue %"int[]" undef, i32* %38, 0
  %40 = insertvalue %"int[]" %39, i64 2, 1
  store %"int[]" %40, %"int[]"* %taddr4, align 8
  %41 = bitcast %"int[]"* %taddr4 to { i8*, i64 }*
  %42 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %41, i32 0, i32 0
  %lo5 = load i8*, i8** %42, align 8
  %43 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %41, i32 0, i32 1
  %hi6 = load i64, i64* %43, align 8
  store <2 x i32> <i32 5, i32 6>, <2 x i32>* %taddr7, align 8
  %44 = bitcast <2 x i32>* %taddr7 to double*
  %45 = load double, double* %44, align 8
  call void @test_test(i64 %35, i8* %lo5, i64 %hi6, double %45)
  %46 = getelementptr inbounds [2 x i32], [2 x i32]* %literal8, i64 0, i64 0
  store i32 2, i32* %46, align 4
  %47 = getelementptr inbounds [2 x i32], [2 x i32]* %literal8, i64 0, i64 1
  store i32 7, i32* %47, align 4
  %48 = bitcast [2 x i32]* %literal8 to i64*
  %49 = load i64, i64* %48, align 4
  %50 = getelementptr inbounds [2 x i32], [2 x i32]* %literal9, i64 0, i64 0
  store i32 2, i32* %50, align 4
  %51 = getelementptr inbounds [2 x i32], [2 x i32]* %literal9, i64 0, i64 1
  store i32 7, i32* %51, align 4
  %52 = bitcast [2 x i32]* %literal9 to i32*
  %53 = insertvalue %"int[]" undef, i32* %52, 0
  %54 = insertvalue %"int[]" %53, i64 2, 1
  store %"int[]" %54, %"int[]"* %taddr10, align 8
  %55 = bitcast %"int[]"* %taddr10 to { i8*, i64 }*
  %56 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %55, i32 0, i32 0
  %lo11 = load i8*, i8** %56, align 8
  %57 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %55, i32 0, i32 1
  %hi12 = load i64, i64* %57, align 8
  store <2 x i32> <i32 2, i32 7>, <2 x i32>* %taddr13, align 8
  %58 = bitcast <2 x i32>* %taddr13 to double*
  %59 = load double, double* %58, align 8
  call void @test_test(i64 %49, i8* %lo11, i64 %hi12, double %59)
  ret void
}