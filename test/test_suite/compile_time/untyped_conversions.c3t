// #target: macos-x64
module test;
import std::io;
struct Foo
{
	int a; int b;
}
fn void test(int[2] a, int[] b, int[<2>] c)
{
	io::printfln("%s %s %s", a, b, c);
}
fn void main()
{
	var $x = { { 1, 2 } };
	Foo[1] abc = (Foo[1])$x;
	Foo def = (Foo)$x[0];
	int[2][1] y = (int[2][1])$x;
	double[2][1] y2 = $x;
	io::printfln("%s %s {%s, %s}", y, y2, def.a, def.b);
	test({ 1, 2 }, { 3, 4}, { 5, 6 });
	var $a = { 2, 7 };
	test($a, $a, $a);
}

/* #expect: test.ll

entry:
  %abc = alloca [1 x %Foo], align 4
  %def = alloca %Foo, align 4
  %y = alloca [1 x [2 x i32]], align 4
  %y2 = alloca [1 x [2 x double]], align 16
  %retparam = alloca i64, align 8
  %taddr = alloca %"char[]", align 8
  %vararg = alloca %"variant[]", align 8
  %varargslots = alloca [4 x %variant], align 16
  %literal = alloca [2 x i32], align 4
  %tempcoerce = alloca i64, align 8
  %literal3 = alloca [2 x i32], align 4
  %taddr4 = alloca %"int[]", align 8
  %taddr7 = alloca <2 x i32>, align 8
  %tempcoerce8 = alloca double, align 8
  %literal9 = alloca [2 x i32], align 4
  %tempcoerce10 = alloca i64, align 8
  %literal11 = alloca [2 x i32], align 4
  %taddr12 = alloca %"int[]", align 8
  %taddr15 = alloca <2 x i32>, align 8
  %tempcoerce16 = alloca double, align 8
  %0 = bitcast [1 x %Foo]* %abc to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %0, i8* align 4 bitcast ([1 x %Foo]* @.__const to i8*), i32 8, i1 false)
  %1 = bitcast %Foo* %def to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %1, i8* align 4 bitcast (%Foo* @.__const.1 to i8*), i32 8, i1 false)
  %2 = bitcast [1 x [2 x i32]]* %y to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 %2, i8* align 4 bitcast ([1 x [2 x i32]]* @.__const.2 to i8*), i32 8, i1 false)
  %3 = bitcast [1 x [2 x double]]* %y2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %3, i8* align 16 bitcast ([1 x [2 x double]]* @.__const.3 to i8*), i32 16, i1 false)
  store %"char[]" { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.4, i32 0, i32 0), i64 14 }, %"char[]"* %taddr, align 8
  %4 = bitcast %"char[]"* %taddr to { i8*, i64 }*
  %5 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %4, i32 0, i32 0
  %lo = load i8*, i8** %5, align 8
  %6 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %4, i32 0, i32 1
  %hi = load i64, i64* %6, align 8
  %7 = bitcast [1 x [2 x i32]]* %y to i8*
  %8 = insertvalue %variant undef, i8* %7, 0
  %9 = insertvalue %variant %8, i64 ptrtoint (%.introspect* @"ct$a1$a2$int" to i64), 1
  %10 = getelementptr inbounds [4 x %variant], [4 x %variant]* %varargslots, i64 0, i64 0
  store %variant %9, %variant* %10, align 16
  %11 = bitcast [1 x [2 x double]]* %y2 to i8*
  %12 = insertvalue %variant undef, i8* %11, 0
  %13 = insertvalue %variant %12, i64 ptrtoint (%.introspect* @"ct$a1$a2$double" to i64), 1
  %14 = getelementptr inbounds [4 x %variant], [4 x %variant]* %varargslots, i64 0, i64 1
  store %variant %13, %variant* %14, align 16
  %15 = getelementptr inbounds %Foo, %Foo* %def, i32 0, i32 0
  %16 = bitcast i32* %15 to i8*
  %17 = insertvalue %variant undef, i8* %16, 0
  %18 = insertvalue %variant %17, i64 ptrtoint (%.introspect* @"ct$int" to i64), 1
  %19 = getelementptr inbounds [4 x %variant], [4 x %variant]* %varargslots, i64 0, i64 2
  store %variant %18, %variant* %19, align 16
  %20 = getelementptr inbounds %Foo, %Foo* %def, i32 0, i32 1
  %21 = bitcast i32* %20 to i8*
  %22 = insertvalue %variant undef, i8* %21, 0
  %23 = insertvalue %variant %22, i64 ptrtoint (%.introspect* @"ct$int" to i64), 1
  %24 = getelementptr inbounds [4 x %variant], [4 x %variant]* %varargslots, i64 0, i64 3
  store %variant %23, %variant* %24, align 16
  %25 = getelementptr inbounds %"variant[]", %"variant[]"* %vararg, i32 0, i32 1
  store i64 4, i64* %25, align 8
  %26 = getelementptr inbounds %"variant[]", %"variant[]"* %vararg, i32 0, i32 0
  %27 = bitcast [4 x %variant]* %varargslots to %variant*
  store %variant* %27, %variant** %26, align 8
  %28 = bitcast %"variant[]"* %vararg to { i8*, i64 }*
  %29 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %28, i32 0, i32 0
  %lo1 = load i8*, i8** %29, align 8
  %30 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %28, i32 0, i32 1
  %hi2 = load i64, i64* %30, align 8
  %31 = call i64 @std_io_printfln(i64* %retparam, i8* %lo, i64 %hi, i8* %lo1, i64 %hi2)
  %not_err = icmp eq i64 %31, 0
  br i1 %not_err, label %after_check, label %voiderr

after_check:                                      ; preds = %entry
  br label %voiderr

voiderr:                                          ; preds = %after_check, %entry
  %32 = getelementptr inbounds [2 x i32], [2 x i32]* %literal, i64 0, i64 0
  store i32 1, i32* %32, align 4
  %33 = getelementptr inbounds [2 x i32], [2 x i32]* %literal, i64 0, i64 1
  store i32 2, i32* %33, align 4
  %34 = bitcast i64* %tempcoerce to i8*
  %35 = bitcast [2 x i32]* %literal to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %34, i8* align 4 %35, i32 8, i1 false)
  %36 = load i64, i64* %tempcoerce, align 8
  %37 = getelementptr inbounds [2 x i32], [2 x i32]* %literal3, i64 0, i64 0
  store i32 3, i32* %37, align 4
  %38 = getelementptr inbounds [2 x i32], [2 x i32]* %literal3, i64 0, i64 1
  store i32 4, i32* %38, align 4
  %39 = bitcast [2 x i32]* %literal3 to i32*
  %40 = insertvalue %"int[]" undef, i32* %39, 0
  %41 = insertvalue %"int[]" %40, i64 2, 1
  store %"int[]" %41, %"int[]"* %taddr4, align 8
  %42 = bitcast %"int[]"* %taddr4 to { i8*, i64 }*
  %43 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %42, i32 0, i32 0
  %lo5 = load i8*, i8** %43, align 8
  %44 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %42, i32 0, i32 1
  %hi6 = load i64, i64* %44, align 8
  store <2 x i32> <i32 5, i32 6>, <2 x i32>* %taddr7, align 8
  %45 = bitcast double* %tempcoerce8 to i8*
  %46 = bitcast <2 x i32>* %taddr7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %45, i8* align 8 %46, i32 8, i1 false)
  %47 = load double, double* %tempcoerce8, align 8
  call void @test_test(i64 %36, i8* %lo5, i64 %hi6, double %47)
  %48 = getelementptr inbounds [2 x i32], [2 x i32]* %literal9, i64 0, i64 0
  store i32 2, i32* %48, align 4
  %49 = getelementptr inbounds [2 x i32], [2 x i32]* %literal9, i64 0, i64 1
  store i32 7, i32* %49, align 4
  %50 = bitcast i64* %tempcoerce10 to i8*
  %51 = bitcast [2 x i32]* %literal9 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %50, i8* align 4 %51, i32 8, i1 false)
  %52 = load i64, i64* %tempcoerce10, align 8
  %53 = getelementptr inbounds [2 x i32], [2 x i32]* %literal11, i64 0, i64 0
  store i32 2, i32* %53, align 4
  %54 = getelementptr inbounds [2 x i32], [2 x i32]* %literal11, i64 0, i64 1
  store i32 7, i32* %54, align 4
  %55 = bitcast [2 x i32]* %literal11 to i32*
  %56 = insertvalue %"int[]" undef, i32* %55, 0
  %57 = insertvalue %"int[]" %56, i64 2, 1
  store %"int[]" %57, %"int[]"* %taddr12, align 8
  %58 = bitcast %"int[]"* %taddr12 to { i8*, i64 }*
  %59 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %58, i32 0, i32 0
  %lo13 = load i8*, i8** %59, align 8
  %60 = getelementptr inbounds { i8*, i64 }, { i8*, i64 }* %58, i32 0, i32 1
  %hi14 = load i64, i64* %60, align 8
  store <2 x i32> <i32 2, i32 7>, <2 x i32>* %taddr15, align 8
  %61 = bitcast double* %tempcoerce16 to i8*
  %62 = bitcast <2 x i32>* %taddr15 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %61, i8* align 8 %62, i32 8, i1 false)
  %63 = load double, double* %tempcoerce16, align 8
  call void @test_test(i64 %52, i8* %lo13, i64 %hi14, double %63)
  ret void
}