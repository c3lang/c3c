// #target: macos-x64
// #safe: yes
module test;
import std;
struct Doc { Head *head; }
struct Head { char[]* title; }
struct Summary
{
 char* title;
}
macro dupe(value)
{
 $typeof(&value) temp = malloc($sizeof(value));
 if (!temp) return OUT_OF_MEMORY~;
 return temp;
}
faultdef BAD_READ, OUT_OF_MEMORY;
fn Doc? readDoc(char[] )
{
	char* str = malloc( + 1);
	return { dupe((Head) { .title = dupe(str[..io::EOF~! - 1])! })! };
}
fn Summary buildSummary(Doc )
{
	return {
	};
}
fn Summary readAndBuildSummary(char[] url)
{
 return buildSummary(readDoc(url)) ?? (Summary) { .title = null, };
}
fn void main()
{
	const char[][] URLS = { "", "", "", "", };
	foreach ( url : URLS)
	{
		Summary summary = readAndBuildSummary(url);
	}
}

/* #expect: test.ll

define i64 @test.readDoc(ptr %0, ptr %1, i64 %2) #0 {
entry:
  %.anon = alloca %"char[]", align 8
  %str = alloca ptr, align 8
  %reterr = alloca i64, align 8
  %literal = alloca %Doc, align 8
  %error_var = alloca i64, align 8
  %literal1 = alloca %Head, align 8
  %error_var2 = alloca i64, align 8
  %error_var3 = alloca i64, align 8
  store ptr %1, ptr %.anon, align 8
  %ptradd = getelementptr inbounds i8, ptr %.anon, i64 8
  store i64 %2, ptr %ptradd, align 8
  %3 = call ptr @std.core.mem.malloc(i64 1) #3
  store ptr %3, ptr %str, align 8
  store ptr null, ptr %literal1, align 8
  %4 = load ptr, ptr %str, align 8
  store i64 ptrtoint (ptr @std.io.EOF to i64), ptr %error_var3, align 8
  br label %guard_block

guard_block:                                      ; preds = %entry
  %5 = load i64, ptr %error_var3, align 8
  ret i64 %5
}

define ptr @test.buildSummary(ptr %0) #0 {
entry:
  %.anon = alloca %Doc, align 8
  %literal = alloca %Summary, align 8
  store ptr %0, ptr %.anon, align 8
  store ptr null, ptr %literal, align 8
  %1 = load ptr, ptr %literal, align 8
  ret ptr %1
}

define ptr @test.readAndBuildSummary(ptr %0, i64 %1) #0 {
entry:
  %url = alloca %"char[]", align 8
  %retparam = alloca %Doc, align 8
  %result = alloca %Summary, align 8
  %literal = alloca %Summary, align 8
  store ptr %0, ptr %url, align 8
  %ptradd = getelementptr inbounds i8, ptr %url, i64 8
  store i64 %1, ptr %ptradd, align 8
  %lo = load ptr, ptr %url, align 8
  %ptradd1 = getelementptr inbounds i8, ptr %url, i64 8
  %hi = load i64, ptr %ptradd1, align 8
  %2 = call i64 @test.readDoc(ptr %retparam, ptr %lo, i64 %hi)
  %not_err = icmp eq i64 %2, 0
  %3 = call i1 @llvm.expect.i1(i1 %not_err, i1 true)
  br i1 %3, label %after_check, label %else_block

after_check:                                      ; preds = %entry
  %4 = load ptr, ptr %retparam, align 8
  %5 = call ptr @test.buildSummary(ptr %4)
  store ptr %5, ptr %result, align 8
  br label %phi_block

else_block:                                       ; preds = %entry
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %literal, ptr align 8 @.__const, i32 8, i1 false)
  br label %phi_block

phi_block:                                        ; preds = %else_block, %after_check
  %val = phi ptr [ %result, %after_check ], [ %literal, %else_block ]
  %6 = load ptr, ptr %val, align 8
  ret ptr %6
}

define void @test.main() #0 {
entry:
  %.anon = alloca i64, align 8
  %url = alloca %"char[]", align 8
  %taddr = alloca i64, align 8
  %taddr1 = alloca i64, align 8
  %varargslots = alloca [2 x %any], align 16
  %indirectarg = alloca %"any[]", align 8
  %taddr3 = alloca i64, align 8
  %taddr4 = alloca i64, align 8
  %varargslots5 = alloca [2 x %any], align 16
  %indirectarg8 = alloca %"any[]", align 8
  %summary = alloca %Summary, align 8
  %result = alloca %Summary, align 8
  %0 = load i64, ptr getelementptr inbounds (i8, ptr @main.URLS, i64 8), align 8
  store i64 0, ptr %.anon, align 8
  br label %loop.cond

loop.cond:                                        ; preds = %checkok9, %entry
  %1 = load i64, ptr %.anon, align 8
  %lt = icmp ult i64 %1, %0
  br i1 %lt, label %loop.body, label %loop.exit

loop.body:                                        ; preds = %loop.cond
  %2 = load i64, ptr getelementptr inbounds (i8, ptr @main.URLS, i64 8), align 8
  %3 = load ptr, ptr @main.URLS, align 8
  %4 = load i64, ptr %.anon, align 8
  %ge = icmp uge i64 %4, %2
  %5 = call i1 @llvm.expect.i1(i1 %ge, i1 false)
  br i1 %5, label %panic, label %checkok

checkok:                                          ; preds = %loop.body
  %ptroffset = getelementptr inbounds [16 x i8], ptr %3, i64 %4
  %6 = ptrtoint ptr %ptroffset to i64
  %7 = urem i64 %6, 8
  %8 = icmp ne i64 %7, 0
  %9 = call i1 @llvm.expect.i1(i1 %8, i1 false)
  br i1 %9, label %panic2, label %checkok9

checkok9:                                         ; preds = %checkok
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %url, ptr align 8 %ptroffset, i32 16, i1 false)
  %lo = load ptr, ptr %url, align 8
  %ptradd10 = getelementptr inbounds i8, ptr %url, i64 8
  %hi = load i64, ptr %ptradd10, align 8
  %10 = call ptr @test.readAndBuildSummary(ptr %lo, i64 %hi)
  store ptr %10, ptr %result, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %summary, ptr align 8 %result, i32 8, i1 false)
  %11 = load i64, ptr %.anon, align 8
  %addnuw = add nuw i64 %11, 1
  store i64 %addnuw, ptr %.anon, align 8
  br label %loop.cond

loop.exit:                                        ; preds = %loop.cond
  ret void

panic:                                            ; preds = %loop.body
  store i64 %2, ptr %taddr, align 8
  %12 = insertvalue %any undef, ptr %taddr, 0
  %13 = insertvalue %any %12, i64 ptrtoint (ptr @"$ct.ulong" to i64), 1
  store i64 %4, ptr %taddr1, align 8
  %14 = insertvalue %any undef, ptr %taddr1, 0
  %15 = insertvalue %any %14, i64 ptrtoint (ptr @"$ct.ulong" to i64), 1
  store %any %13, ptr %varargslots, align 16
  %ptradd = getelementptr inbounds i8, ptr %varargslots, i64 16
  store %any %15, ptr %ptradd, align 16
  %16 = insertvalue %"any[]" undef, ptr %varargslots, 0
  %"$$temp" = insertvalue %"any[]" %16, i64 2, 1
  store %"any[]" %"$$temp", ptr %indirectarg, align 8
  call void @std.core.builtin.panicf(ptr @.panic_msg, i64 59, ptr @.file, i64 25, ptr @.func, i64 4, i32 33, ptr byval(%"any[]") align 8 %indirectarg) #4
  unreachable

panic2:                                           ; preds = %checkok
  store i64 8, ptr %taddr3, align 8
  %17 = insertvalue %any undef, ptr %taddr3, 0
  %18 = insertvalue %any %17, i64 ptrtoint (ptr @"$ct.ulong" to i64), 1
  store i64 %7, ptr %taddr4, align 8
  %19 = insertvalue %any undef, ptr %taddr4, 0
  %20 = insertvalue %any %19, i64 ptrtoint (ptr @"$ct.ulong" to i64), 1
  store %any %18, ptr %varargslots5, align 16
  %ptradd6 = getelementptr inbounds i8, ptr %varargslots5, i64 16
  store %any %20, ptr %ptradd6, align 16
  %21 = insertvalue %"any[]" undef, ptr %varargslots5, 0
  %"$$temp7" = insertvalue %"any[]" %21, i64 2, 1
  store %"any[]" %"$$temp7", ptr %indirectarg8, align 8
  call void @std.core.builtin.panicf(ptr @.panic_msg.1, i64 94, ptr @.file, i64 25, ptr @.func, i64 4, i32 33, ptr byval(%"any[]") align 8 %indirectarg8) #4
  unreachable
}
