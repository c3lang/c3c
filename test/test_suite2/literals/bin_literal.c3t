// #target: macos-x64
module test;
import std::io;
import std::bits;
fn void main()
{
	int a = 123;
	int b = -23;
	int c = $$min(a, b);
	int d = $$max(a, b);
	io::printfln("%d %d", c, d);
	char z = 0b1101_1101;
	io::printfln("%b %b %b", z, z.rotr(1), z.rotl(1));
}

/* #expect: test.ll

define void @test_main() #0 {
entry:
  %a = alloca i32, align 4
  %b = alloca i32, align 4
  %c = alloca i32, align 4
  %d = alloca i32, align 4
  %retparam = alloca i64, align 8
  %varargslots = alloca [2 x %variant], align 16
  %z = alloca i8, align 1
  %retparam1 = alloca i64, align 8
  %varargslots2 = alloca [3 x %variant], align 16
  %i = alloca i8, align 1
  %shift = alloca i8, align 1
  %taddr = alloca i8, align 1
  %i3 = alloca i8, align 1
  %shift4 = alloca i8, align 1
  %taddr5 = alloca i8, align 1
  store i32 123, ptr %a, align 4
  store i32 -23, ptr %b, align 4
  %0 = load i32, ptr %a, align 4
  %1 = load i32, ptr %b, align 4
  %2 = call i32 @llvm.smin.i32(i32 %0, i32 %1)
  store i32 %2, ptr %c, align 4
  %3 = load i32, ptr %a, align 4
  %4 = load i32, ptr %b, align 4
  %5 = call i32 @llvm.smax.i32(i32 %3, i32 %4)
  store i32 %5, ptr %d, align 4
  %6 = insertvalue %variant undef, ptr %c, 0
  %7 = insertvalue %variant %6, i64 ptrtoint (ptr @"ct$int" to i64), 1
  %8 = getelementptr inbounds [2 x %variant], ptr %varargslots, i64 0, i64 0
  store %variant %7, ptr %8, align 16
  %9 = insertvalue %variant undef, ptr %d, 0
  %10 = insertvalue %variant %9, i64 ptrtoint (ptr @"ct$int" to i64), 1
  %11 = getelementptr inbounds [2 x %variant], ptr %varargslots, i64 0, i64 1
  store %variant %10, ptr %11, align 16
  %12 = call i64 @std_io_printfln(ptr %retparam, ptr @.str, i64 5, ptr %varargslots, i64 2)
  %not_err = icmp eq i64 %12, 0
  br i1 %not_err, label %after_check, label %voiderr

after_check:                                      ; preds = %entry
  br label %voiderr

voiderr:                                          ; preds = %after_check, %entry
  store i8 -35, ptr %z, align 1
  %13 = insertvalue %variant undef, ptr %z, 0
  %14 = insertvalue %variant %13, i64 ptrtoint (ptr @"ct$char" to i64), 1
  %15 = getelementptr inbounds [3 x %variant], ptr %varargslots2, i64 0, i64 0
  store %variant %14, ptr %15, align 16
  %16 = load i8, ptr %z, align 1
  store i8 %16, ptr %i, align 1
  store i8 1, ptr %shift, align 1
  %17 = load i8, ptr %i, align 1
  %18 = load i8, ptr %i, align 1
  %19 = load i8, ptr %shift, align 1
  %20 = call i8 @llvm.fshr.i8(i8 %17, i8 %18, i8 %19)
  store i8 %20, ptr %taddr, align 1
  %21 = insertvalue %variant undef, ptr %taddr, 0
  %22 = insertvalue %variant %21, i64 ptrtoint (ptr @"ct$char" to i64), 1
  %23 = getelementptr inbounds [3 x %variant], ptr %varargslots2, i64 0, i64 1
  store %variant %22, ptr %23, align 16
  %24 = load i8, ptr %z, align 1
  store i8 %24, ptr %i3, align 1
  store i8 1, ptr %shift4, align 1
  %25 = load i8, ptr %i3, align 1
  %26 = load i8, ptr %i3, align 1
  %27 = load i8, ptr %shift4, align 1
  %28 = call i8 @llvm.fshl.i8(i8 %25, i8 %26, i8 %27)
  store i8 %28, ptr %taddr5, align 1
  %29 = insertvalue %variant undef, ptr %taddr5, 0
  %30 = insertvalue %variant %29, i64 ptrtoint (ptr @"ct$char" to i64), 1
  %31 = getelementptr inbounds [3 x %variant], ptr %varargslots2, i64 0, i64 2
  store %variant %30, ptr %31, align 16
  %32 = call i64 @std_io_printfln(ptr %retparam1, ptr @.str.1, i64 8, ptr %varargslots2, i64 3)
  %not_err6 = icmp eq i64 %32, 0
  br i1 %not_err6, label %after_check7, label %voiderr8

after_check7:                                     ; preds = %voiderr
  br label %voiderr8

voiderr8:                                         ; preds = %after_check7, %voiderr
  ret void
}
