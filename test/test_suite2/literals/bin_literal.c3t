// #target: macos-x64
module test;
import std::io;
import std::bits;
fn void main()
{
	int a = 123;
	int b = -23;
	int c = $$min(a, b);
	int d = $$max(a, b);
	io::printfln("%d %d", c, d);
	char z = 0b1101_1101;
	io::printfln("%b %b %b", z, z.rotr(1), z.rotl(1));
}

/* #expect: test.ll

define void @test_main() #0 {
entry:
  %a = alloca i32, align 4
  %b = alloca i32, align 4
  %c = alloca i32, align 4
  %d = alloca i32, align 4
  %retparam = alloca i64, align 8
  %taddr = alloca %"char[]", align 8
  %vararg = alloca %"variant[]", align 8
  %varargslots = alloca [2 x %variant], align 16
  %z = alloca i8, align 1
  %retparam3 = alloca i64, align 8
  %taddr4 = alloca %"char[]", align 8
  %vararg7 = alloca %"variant[]", align 8
  %varargslots8 = alloca [3 x %variant], align 16
  %i = alloca i8, align 1
  %shift = alloca i8, align 1
  %taddr9 = alloca i8, align 1
  %i10 = alloca i8, align 1
  %shift11 = alloca i8, align 1
  %taddr12 = alloca i8, align 1
  store i32 123, ptr %a, align 4
  store i32 -23, ptr %b, align 4
  %0 = load i32, ptr %a, align 4
  %1 = load i32, ptr %b, align 4
  %2 = call i32 @llvm.smin.i32(i32 %0, i32 %1)
  store i32 %2, ptr %c, align 4
  %3 = load i32, ptr %a, align 4
  %4 = load i32, ptr %b, align 4
  %5 = call i32 @llvm.smax.i32(i32 %3, i32 %4)
  store i32 %5, ptr %d, align 4
  store %"char[]" { ptr @.str, i64 5 }, ptr %taddr, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %taddr, i32 0, i32 0
  %lo = load ptr, ptr %6, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %taddr, i32 0, i32 1
  %hi = load i64, ptr %7, align 8
  %8 = insertvalue %variant undef, ptr %c, 0
  %9 = insertvalue %variant %8, i64 ptrtoint (ptr @"ct$int" to i64), 1
  %10 = getelementptr inbounds [2 x %variant], ptr %varargslots, i64 0, i64 0
  store %variant %9, ptr %10, align 16
  %11 = insertvalue %variant undef, ptr %d, 0
  %12 = insertvalue %variant %11, i64 ptrtoint (ptr @"ct$int" to i64), 1
  %13 = getelementptr inbounds [2 x %variant], ptr %varargslots, i64 0, i64 1
  store %variant %12, ptr %13, align 16
  %14 = getelementptr inbounds %"variant[]", ptr %vararg, i32 0, i32 1
  store i64 2, ptr %14, align 8
  %15 = getelementptr inbounds %"variant[]", ptr %vararg, i32 0, i32 0
  store ptr %varargslots, ptr %15, align 8
  %16 = getelementptr inbounds { ptr, i64 }, ptr %vararg, i32 0, i32 0
  %lo1 = load ptr, ptr %16, align 8
  %17 = getelementptr inbounds { ptr, i64 }, ptr %vararg, i32 0, i32 1
  %hi2 = load i64, ptr %17, align 8
  %18 = call i64 @std_io_printfln(ptr %retparam, ptr %lo, i64 %hi, ptr %lo1, i64 %hi2)
  %not_err = icmp eq i64 %18, 0
  br i1 %not_err, label %after_check, label %voiderr

after_check:                                      ; preds = %entry
  br label %voiderr

voiderr:                                          ; preds = %after_check, %entry
  store i8 -35, ptr %z, align 1
  store %"char[]" { ptr @.str.1, i64 8 }, ptr %taddr4, align 8
  %19 = getelementptr inbounds { ptr, i64 }, ptr %taddr4, i32 0, i32 0
  %lo5 = load ptr, ptr %19, align 8
  %20 = getelementptr inbounds { ptr, i64 }, ptr %taddr4, i32 0, i32 1
  %hi6 = load i64, ptr %20, align 8
  %21 = insertvalue %variant undef, ptr %z, 0
  %22 = insertvalue %variant %21, i64 ptrtoint (ptr @"ct$char" to i64), 1
  %23 = getelementptr inbounds [3 x %variant], ptr %varargslots8, i64 0, i64 0
  store %variant %22, ptr %23, align 16
  %24 = load i8, ptr %z, align 1
  store i8 %24, ptr %i, align 1
  store i8 1, ptr %shift, align 1
  %25 = load i8, ptr %i, align 1
  %26 = load i8, ptr %i, align 1
  %27 = load i8, ptr %shift, align 1
  %28 = call i8 @llvm.fshr.i8(i8 %25, i8 %26, i8 %27)
  store i8 %28, ptr %taddr9, align 1
  %29 = insertvalue %variant undef, ptr %taddr9, 0
  %30 = insertvalue %variant %29, i64 ptrtoint (ptr @"ct$char" to i64), 1
  %31 = getelementptr inbounds [3 x %variant], ptr %varargslots8, i64 0, i64 1
  store %variant %30, ptr %31, align 16
  %32 = load i8, ptr %z, align 1
  store i8 %32, ptr %i10, align 1
  store i8 1, ptr %shift11, align 1
  %33 = load i8, ptr %i10, align 1
  %34 = load i8, ptr %i10, align 1
  %35 = load i8, ptr %shift11, align 1
  %36 = call i8 @llvm.fshl.i8(i8 %33, i8 %34, i8 %35)
  store i8 %36, ptr %taddr12, align 1
  %37 = insertvalue %variant undef, ptr %taddr12, 0
  %38 = insertvalue %variant %37, i64 ptrtoint (ptr @"ct$char" to i64), 1
  %39 = getelementptr inbounds [3 x %variant], ptr %varargslots8, i64 0, i64 2
  store %variant %38, ptr %39, align 16
  %40 = getelementptr inbounds %"variant[]", ptr %vararg7, i32 0, i32 1
  store i64 3, ptr %40, align 8
  %41 = getelementptr inbounds %"variant[]", ptr %vararg7, i32 0, i32 0
  store ptr %varargslots8, ptr %41, align 8
  %42 = getelementptr inbounds { ptr, i64 }, ptr %vararg7, i32 0, i32 0
  %lo13 = load ptr, ptr %42, align 8
  %43 = getelementptr inbounds { ptr, i64 }, ptr %vararg7, i32 0, i32 1
  %hi14 = load i64, ptr %43, align 8
  %44 = call i64 @std_io_printfln(ptr %retparam3, ptr %lo5, i64 %hi6, ptr %lo13, i64 %hi14)
  %not_err15 = icmp eq i64 %44, 0
  br i1 %not_err15, label %after_check16, label %voiderr17

after_check16:                                    ; preds = %voiderr
  br label %voiderr17

voiderr17:                                        ; preds = %after_check16, %voiderr
  ret void
}
