// Copyright (c) 2026 Koni Marti. All rights reserved.
// Use of this source code is governed by the MIT license.
// Auto-generated by cpgen on 2026-02-02 14:20:52.
<*
 Module providing generic single‑byte code page to UTF‑8 conversion.

 This module implements a compact, table‑driven approach for single-byte
 (8‑bit) encodings (e.g. CP437, CP850, CP866, CP125x). It is designed so
 that each concrete code page only needs to supply a small, static
 mapping table; the conversion logic is shared.

 The design has two main goals:

 - Fast decode from code page to UTF‑8 with a single table lookup per byte.
 - Memory‑efficient encode from UTF‑8 to code page without a large
   Unicode‑to‑byte array (no 64k reverse map per code page).

 The design of CodePageTable and the packed reverse mapping is conceptually
 similar to golang.org/x/text/encoding/charmap.

 Client code should import the desired mapping module (for example,
 std::encoding::codepage::cp437) and invoke its decode and encode functions.
 Each generated code page module follows this convention and exposes the same
 high‑level interface.

 *>
module std::encoding::codepage;
import std::sort;

const uint MASK @private = (1u << 24) - 1;

<*
 CodePageTable contains the bidirectional mapping tables for a single‑byte code
 page.

 to_codepoint is the forward map from code-page byte (0x00–0xFF) to its UTF‑8
 sequence. The array index is the raw byte value. Each entry is a CodePoint
 with the UTF‑8 bytes and their length.

 from_codepoint is the reverse map from Unicode scalar value to code-page byte,
 stored in a compact, sorted form to keep memory usage low.

   Packing scheme:
     Each uint entry encodes both the code-page byte and the Unicode
     scalar:

         high 8 bits = code-page byte value (0x00–0xFF)
         low 24 bits = Unicode scalar value (code point)

     Example:
         entry = (byte_value << 24) | codepoint;

   Ordering:
     The table is sorted by the low 24 bits (codepoints). This allows
     binary search over the Unicode scalar values without a 64k
     reverse‑lookup table. For any given code page, there are at most
     256 mappings, so a log2(256) or 8 step search is enough.

   Usage in encoding (UTF‑8 to code page):
     1. Decode one Unicode scalar from the UTF‑8 input.
     2. Binary‑search for an entry whose low 24 bits equal
        that scalar.
     3. If found, extract the code-page byte from the high 8 bits and
        emit it.
     4. If not found, emit a caller‑supplied replacement byte (typically
        0x1A / SUB).

   This representation trades a small amount of per‑character CPU
   (binary search) for a very compact, cache‑friendly table.
*>
struct CodePageTable
{
    CodePoint[256] to_codepoint;
    uint[256]      from_codepoint;
}

<*
 UTF‑8 representation of a single code point.

 Each entry stores up to 4 UTF‑8 bytes in bytes and the number of
 bytes actually used in len. This avoids recomputing the UTF‑8
 encoding at runtime.

 For single‑byte code pages, all mapped Unicode values are in the BMP,
 so at most 3 bytes are needed, but 4 bytes are reserved for symmetry.
*>
struct CodePoint
{
	char[4] bytes;
	char    len;
}
fn char[] CodePoint.symbol(&self) @inline => self.bytes[:self.len];

<*
 Decode a code-page byte buffer into a UTF‑8 string.

 @param [&inout] allocator : "Allocator used for the returned string."
 @param src                : "Input byte array in the given code page."
 @param [&inout] table     : "Code page table describing the mapping for this encoding."
 @return "String in UTF-8."
*>
fn String? decode_codepage(Allocator allocator, char[] src, CodePageTable *table)
{
	DString buf = dstring::new(allocator);
	buf.reserve(decode_len(src, table));
	foreach (c: src)
	{
		buf.append_bytes(table.to_codepoint[c].symbol());
	}
	return buf.str_view();
}

<*
 Encode a UTF‑8 string into a single‑byte code page.

 @param [&inout] allocator : "Allocator used for the returned byte array."
 @param src                : "Input byte array in UTF-8"
 @param [&inout] table     : "Code page table describing the mapping for this encoding."
 @param replacement        : "Byte to emit when Unicode scalar cannot be represented in the target code page."
 @return "Byte array in the given code page."
*>
fn char[]? encode_codepoints(Allocator allocator, char[] src, CodePageTable *table,
	char replacement = 0x1a)
{
	DString buf = dstring::new(allocator);
	buf.reserve(encode_len(src, table));

	usz n = src.len;
	for (usz i = 0; i < n;)
	{
		usz rem = n - i;
		rem = rem < 4 ? rem : 4;
		Char32 codepoint = conv::utf8_to_char32(&src[i], &rem)!;
		i += rem;

		usz index = sort::binarysearch(table.from_codepoint[..], codepoint,
		fn int(uint a, uint b){
			return (a & MASK) - (b & MASK);
		});

		uint encoded = table.from_codepoint[index];
		char byte = (char)(encoded >> 24);
		uint unicode = encoded & MASK;
		buf.append_char(unicode == codepoint ? byte: replacement);
	}
	return buf.str_view();
}

fn usz decode_len(char[] src, CodePageTable *table) @inline
{
	usz n;
	foreach (c: src) n += table.to_codepoint[c].len;
	return n;
}

fn usz encode_len(char[] src, CodePageTable *table) @inline
{
	return conv::utf8_codepoints((String)src);
}

